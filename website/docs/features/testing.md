# Testing

Zuraffa's architecture makes testing straightforward. The `--test` flag generates comprehensive unit tests for your UseCases with mock setup and multiple test scenarios.

## Generated Test Structure

```bash
zfa generate Product --methods=get,getList,create,update,delete --repository --test
```

Generates:

```
test/
└── domain/
    └── usecases/
        └── product/
            ├── get_product_usecase_test.dart
            ├── get_product_list_usecase_test.dart
            ├── create_product_usecase_test.dart
            ├── update_product_usecase_test.dart
            └── delete_product_usecase_test.dart
```

## Generated Test Example

```dart
// test/domain/usecases/product/get_product_usecase_test.dart
// Generated by zfa

import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:zuraffa/zuraffa.dart';

import '../../../lib/src/domain/entities/product/product.dart';
import '../../../lib/src/domain/repositories/product_repository.dart';
import '../../../lib/src/domain/usecases/product/get_product_usecase.dart';

class MockProductRepository extends Mock implements ProductRepository {}

void main() {
  late GetProductUseCase useCase;
  late MockProductRepository mockRepository;

  setUp(() {
    mockRepository = MockProductRepository();
    useCase = GetProductUseCase(mockRepository);
  });

  group('GetProductUseCase', () {
    const tId = 'test-id-123';
    final tProduct = Product(
      id: tId,
      name: 'Test Product',
      price: 29.99,
    );

    test('should get product from repository', () async {
      // Arrange
      when(() => mockRepository.get(tId))
          .thenAnswer((_) async => tProduct);

      // Act
      final result = await useCase(tId);

      // Assert
      expect(result.isSuccess, true);
      expect(result.getOrNull(), equals(tProduct));
      verify(() => mockRepository.get(tId)).called(1);
    });

    test('should return NotFoundFailure when product not found', () async {
      // Arrange
      when(() => mockRepository.get(tId))
          .thenThrow(NotFoundFailure('Product not found'));

      // Act
      final result = await useCase(tId);

      // Assert
      expect(result.isFailure, true);
      expect(result.getFailureOrNull(), isA<NotFoundFailure>());
    });

    test('should return NetworkFailure on connection error', () async {
      // Arrange
      when(() => mockRepository.get(tId))
          .thenThrow(NetworkFailure('No internet'));

      // Act
      final result = await useCase(tId);

      // Assert
      expect(result.isFailure, true);
      expect(result.getFailureOrNull(), isA<NetworkFailure>());
    });

    test('should return UnknownFailure on unexpected error', () async {
      // Arrange
      when(() => mockRepository.get(tId))
          .thenThrow(Exception('Unexpected'));

      // Act
      final result = await useCase(tId);

      // Assert
      expect(result.isFailure, true);
      expect(result.getFailureOrNull(), isA<UnknownFailure>());
    });

    test('should return CancellationFailure when cancelled', () async {
      // Arrange
      final cancelToken = CancelToken();
      when(() => mockRepository.get(tId))
          .thenAnswer((_) async {
        cancelToken.cancel('Test cancellation');
        return tProduct;
      });

      // Act
      final result = await useCase(tId, cancelToken: cancelToken);

      // Assert
      expect(result.isFailure, true);
      expect(result.getFailureOrNull(), isA<CancellationFailure>());
    });
  });
}
```

## Test Coverage

Generated tests cover:

| Scenario | Description |
|----------|-------------|
| **Success** | Normal operation returns expected data |
| **Not Found** | Entity doesn't exist |
| **Network Error** | Connection issues |
| **Server Error** | 5xx responses |
| **Validation Error** | Invalid input data |
| **Unauthorized** | Authentication required |
| **Forbidden** | Permission denied |
| **Timeout** | Request timeout |
| **Unknown Error** | Unexpected exceptions |
| **Cancellation** | Operation cancelled mid-flight |

## Running Tests

```bash
# Run all tests
flutter test

# Run tests for specific entity
flutter test test/domain/usecases/product/

# Run with coverage
flutter test --coverage

# Run specific test file
flutter test test/domain/usecases/product/get_product_usecase_test.dart
```

## Testing Patterns

### Testing UseCases

```dart
group('CreateProductUseCase', () {
  final tProduct = Product(
    id: 'new-id',
    name: 'New Product',
    price: 99.99,
  );

  test('should create product successfully', () async {
    // Arrange
    when(() => mockRepository.create(tProduct))
        .thenAnswer((_) async => tProduct);

    // Act
    final result = await useCase(tProduct);

    // Assert
    expect(result.isSuccess, true);
    verify(() => mockRepository.create(tProduct)).called(1);
  });

  test('should return ValidationFailure for invalid product', () async {
    // Arrange
    final invalidProduct = Product(
      id: '',
      name: '',
      price: -10,
    );
    when(() => mockRepository.create(invalidProduct))
        .thenThrow(ValidationFailure('Invalid data'));

    // Act
    final result = await useCase(invalidProduct);

    // Assert
    expect(result.isFailure, true);
    expect(result.getFailureOrNull(), isA<ValidationFailure>());
  });
});
```

### Testing StreamUseCases

```dart
group('WatchProductUseCase', () {
  test('should emit products as stream', () async {
    // Arrange
    final products = [
      Product(id: '1', name: 'Product 1', price: 10),
      Product(id: '2', name: 'Product 2', price: 20),
    ];
    when(() => mockRepository.watchList())
        .thenAnswer((_) => Stream.fromIterable([products]));

    // Act
    final results = await useCase(const NoParams()).toList();

    // Assert
    expect(results.length, 1);
    expect(results.first.isSuccess, true);
    expect(results.first.getOrNull(), equals(products));
  });

  test('should emit failure on stream error', () async {
    // Arrange
    when(() => mockRepository.watchList())
        .thenAnswer((_) => Stream.error(NetworkFailure('Connection lost')));

    // Act
    final results = await useCase(const NoParams()).toList();

    // Assert
    expect(results.first.isFailure, true);
    expect(results.first.getFailureOrNull(), isA<NetworkFailure>());
  });
});
```

### Testing CompletableUseCases

```dart
group('DeleteProductUseCase', () {
  const tId = 'product-to-delete';

  test('should delete product successfully', () async {
    // Arrange
    when(() => mockRepository.delete(tId))
        .thenAnswer((_) async {});

    // Act
    final result = await useCase(tId);

    // Assert
    expect(result.isSuccess, true);
    verify(() => mockRepository.delete(tId)).called(1);
  });

  test('should return NotFoundFailure when product does not exist', () async {
    // Arrange
    when(() => mockRepository.delete(tId))
        .thenThrow(NotFoundFailure('Product not found'));

    // Act
    final result = await useCase(tId);

    // Assert
    expect(result.isFailure, true);
    expect(result.getFailureOrNull(), isA<NotFoundFailure>());
  });
});
```

### Testing Repositories

```dart
group('DataProductRepository', () {
  late MockProductDataSource mockDataSource;
  late DataProductRepository repository;

  setUp(() {
    mockDataSource = MockProductDataSource();
    repository = DataProductRepository(mockDataSource);
  });

  test('should delegate get to datasource', () async {
    // Arrange
    when(() => mockDataSource.get(any()))
        .thenAnswer((_) async => tProduct);

    // Act
    final result = await repository.get('id');

    // Assert
    expect(result, equals(tProduct));
    verify(() => mockDataSource.get('id')).called(1);
  });
});
```

### Testing with Mock Data

Use generated mock data for consistent test data:

```dart
import '../../lib/src/data/mock/product_mock_data.dart';

group('GetProductUseCase with Mock Data', () {
  test('should return mock product', () async {
    // Arrange
    final mockProduct = ProductMockData.sampleProduct;
    when(() => mockRepository.get(mockProduct.id))
        .thenAnswer((_) async => mockProduct);

    // Act
    final result = await useCase(mockProduct.id);

    // Assert
    expect(result.getOrNull()?.id, equals(mockProduct.id));
    expect(result.getOrNull()?.name, equals(mockProduct.name));
  });

  test('should handle large dataset', () async {
    // Arrange
    final largeList = ProductMockData.largeProductList;
    when(() => mockRepository.getList())
        .thenAnswer((_) async => largeList);

    // Act
    final result = await getListUseCase(const NoParams());

    // Assert
    expect(result.getOrNull()?.length, equals(100));
  });
});
```

## Testing Controllers

```dart
group('ProductController', () {
  late ProductController controller;
  late MockProductPresenter mockPresenter;

  setUp(() {
    mockPresenter = MockProductPresenter();
    controller = ProductController(mockPresenter);
    controller.initListeners();
  });

  tearDown(() {
    controller.dispose();
  });

  test('should update state on successful load', () async {
    // Arrange
    final products = [ProductMockData.sampleProduct];
    when(() => mockPresenter.getProductList())
        .thenAnswer((_) async => Result.success(products));

    // Act
    await controller.getProductList();

    // Assert
    expect(controller.viewState.isGettingList, false);
    expect(controller.viewState.productList, equals(products));
    expect(controller.viewState.error, isNull);
  });

  test('should update state on failure', () async {
    // Arrange
    final failure = NetworkFailure('No connection');
    when(() => mockPresenter.getProductList())
        .thenAnswer((_) async => Result.failure(failure));

    // Act
    await controller.getProductList();

    // Assert
    expect(controller.viewState.isGettingList, false);
    expect(controller.viewState.error, equals(failure));
  });

  test('should set loading state while fetching', () async {
    // Arrange
    final completer = Completer<Result<List<Product>, AppFailure>>();
    when(() => mockPresenter.getProductList())
        .thenAnswer((_) => completer.future);

    // Act
    final future = controller.getProductList();

    // Assert - during loading
    expect(controller.viewState.isGettingList, true);

    // Complete the operation
    completer.complete(Result.success([]));
    await future;

    // Assert - after completion
    expect(controller.viewState.isGettingList, false);
  });
});
```

## Integration Testing

```dart
// test/integration/product_flow_test.dart
void main() {
  group('Product Flow Integration', () {
    late ProductRepository repository;
    late GetProductUseCase getUseCase;
    late CreateProductUseCase createUseCase;

    setUp(() {
      // Use mock datasource for integration tests
      final dataSource = ProductMockDataSource();
      repository = DataProductRepository(dataSource);
      getUseCase = GetProductUseCase(repository);
      createUseCase = CreateProductUseCase(repository);
    });

    test('should create and retrieve product', () async {
      // Arrange
      final newProduct = Product(
        id: 'integration-test',
        name: 'Integration Test Product',
        price: 99.99,
      );

      // Act - Create
      final createResult = await createUseCase(newProduct);
      expect(createResult.isSuccess, true);

      // Act - Retrieve
      final getResult = await getUseCase('integration-test');
      
      // Assert
      expect(getResult.isSuccess, true);
      expect(getResult.getOrNull()?.name, equals('Integration Test Product'));
    });
  });
}
```

## Widget Testing

```dart
// test/presentation/product_view_test.dart
void main() {
  group('ProductView', () {
    late MockProductRepository mockRepository;

    setUp(() {
      mockRepository = MockProductRepository();
    });

    testWidgets('should display loading indicator', (tester) async {
      // Arrange
      when(() => mockRepository.getList())
          .thenAnswer((_) => Future.delayed(
                Duration(seconds: 1),
                () => [],
              ));

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: ProductView(productRepository: mockRepository),
        ),
      );

      // Assert
      expect(find.byType(CircularProgressIndicator), findsOneWidget);
    });

    testWidgets('should display product list', (tester) async {
      // Arrange
      final products = ProductMockData.sampleList;
      when(() => mockRepository.getList())
          .thenAnswer((_) async => products);

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: ProductView(productRepository: mockRepository),
        ),
      );
      await tester.pumpAndSettle();

      // Assert
      expect(find.byType(ListView), findsOneWidget);
      expect(find.text(products.first.name), findsOneWidget);
    });

    testWidgets('should display error message', (tester) async {
      // Arrange
      when(() => mockRepository.getList())
          .thenThrow(NetworkFailure('No connection'));

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: ProductView(productRepository: mockRepository),
        ),
      );
      await tester.pumpAndSettle();

      // Assert
      expect(find.textContaining('No connection'), findsOneWidget);
    });
  });
}
```

## Best Practices

### 1. Arrange-Act-Assert

Structure tests clearly:

```dart
test('should do something', () async {
  // Arrange - setup mocks and data
  when(() => mock.repository()).thenAnswer(...);
  
  // Act - execute the code
  final result = await useCase(params);
  
  // Assert - verify outcomes
  expect(result.isSuccess, true);
});
```

### 2. Test Edge Cases

```dart
test('should handle empty list', () async {
  when(() => mockRepository.getList())
      .thenAnswer((_) async => []);
  
  final result = await useCase(const NoParams());
  
  expect(result.getOrNull(), isEmpty);
});

test('should handle very large list', () async {
  final largeList = List.generate(10000, (i) => Product(...));
  when(() => mockRepository.getList())
      .thenAnswer((_) async => largeList);
  
  final result = await useCase(const NoParams());
  
  expect(result.getOrNull()?.length, equals(10000));
});
```

### 3. Verify Interactions

```dart
test('should not call repository on cache hit', () async {
  // First call - cache miss
  await useCase('id');
  
  // Second call - should use cache
  await useCase('id');
  
  // Repository should only be called once
  verify(() => mockRepository.get('id')).called(1);
});
```

### 4. Use Shared Setups

```dart
group('ProductUseCases', () {
  late MockProductRepository repository;
  late GetProductUseCase getUseCase;
  late CreateProductUseCase createUseCase;

  setUp(() {
    repository = MockProductRepository();
    getUseCase = GetProductUseCase(repository);
    createUseCase = CreateProductUseCase(repository);
  });

  // All tests in this group share the setup
});
```

---

## Next Steps

- [Mock Data](./mock-data) - Using generated mock data in tests
- [CLI Commands](../cli/commands) - Generate tests with `--test`
- [Architecture](../architecture/overview) - Understand what you're testing