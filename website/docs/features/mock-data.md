# Mock Data Generation

Zuraffa can automatically generate complete mock data infrastructure for development and testing. This includes realistic mock data, a fully functional mock datasource, and seamless DI integration.

## Overview

The `--mock` flag generates:

1. **Mock Data File** - Realistic sample data with variations
2. **Mock DataSource** - Fully functional implementation of your DataSource interface
3. **Nested Entity Support** - Automatic handling of complex entity relationships

```bash
zfa generate Product --methods=get,getList --repository --data --mock
```

Generates:

```
lib/src/
├── data/
│   ├── mock/
│   │   └── product_mock_data.dart        # Mock data values
│   └── data_sources/
│       └── product/
│           ├── product_data_source.dart   # Abstract interface
│           ├── product_remote_data_source.dart
│           └── product_mock_data_source.dart  # Mock implementation
```

## Generated Mock Data

### Mock Data File

```dart
// lib/src/data/mock/product_mock_data.dart
// Generated by zfa

import '../../domain/entities/product/product.dart';
import '../../domain/entities/enums/index.dart';  // Only if entity has enums

class ProductMockData {
  static final List<Product> products = [
    Product(
      id: 'id 1',
      name: 'name 1',
      description: 'description 1',
      price: 29.99,
      category: Category.values[1],  // Enum support
      isActive: true,
      createdAt: DateTime(2024, 1, 1),
      updatedAt: DateTime(2024, 1, 15),
    ),
    Product(
      id: 'id 2',
      name: 'name 2',
      description: 'description 2',
      price: 49.99,
      category: Category.values[2],
      isActive: false,
      createdAt: DateTime(2024, 2, 1),
      updatedAt: DateTime(2024, 2, 15),
    ),
    Product(
      id: 'id 3',
      name: 'name 3',
      description: 'description 3',
      price: 19.99,
      category: Category.values[0],
      isActive: true,
      createdAt: DateTime(2024, 3, 1),
      updatedAt: DateTime(2024, 3, 15),
    ),
  ];

  // Quick accessors
  static Product get sampleProduct => products.first;
  static List<Product> get sampleList => products;
  static List<Product> get emptyList => [];

  // Large dataset for performance testing
  static List<Product> get largeProductList => List.generate(
    100,
    (index) => _createProduct(index + 1000),
  );

  // Seeded generation for consistent data
  static Product _createProduct(int seed) {
    return Product(
      id: 'id $seed',
      name: 'name $seed',
      description: 'description $seed',
      price: (seed * 10.0),
      category: Category.values[seed % 3],
      isActive: seed % 2 == 1,
      createdAt: DateTime(2024, 1, 1).add(Duration(days: seed)),
      updatedAt: DateTime(2024, 1, 1).add(Duration(days: seed + 7)),
    );
  }
}
```

### Mock DataSource

```dart
// lib/src/data/data_sources/product/product_mock_data_source.dart
// Generated by zfa

import 'dart:async';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/product/product.dart';
import '../../mock/product_mock_data.dart';
import 'product_data_source.dart';

class ProductMockDataSource
    with Loggable, FailureHandler
    implements ProductDataSource {
  final Duration _delay;

  ProductMockDataSource({Duration? delay})
      : _delay = delay ?? const Duration(milliseconds: 100);

  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing ProductMockDataSource');
    // Mock initialization - simulates network delay
    await Future.delayed(const Duration(seconds: 1));
    logger.info('ProductMockDataSource initialized');
  }

  @override
  Stream<bool> get isInitialized => Stream.value(true);

  @override
  Future<Product> get(String id) async {
    logger.info('Getting Product with id: $id');
    await Future.delayed(_delay);
    
    final item = ProductMockData.products.firstWhere(
      (item) => item.id == id,
      orElse: () => throw NotFoundFailure('Product not found: $id'),
    );
    
    logger.info('Successfully retrieved Product: $id');
    return item;
  }

  @override
  Future<List<Product>> getList(ListQueryParams params) async {
    logger.info('Getting Product list with params: $params');
    await Future.delayed(_delay);
    
    var items = ProductMockData.products;

    // Apply limit if specified
    if (params.limit != null && params.limit! > 0) {
      items = items.take(params.limit!).toList();
    }

    logger.info('Successfully retrieved ${items.length} Products');
    return items;
  }

  @override
  Future<Product> create(Product product) async {
    logger.info('Creating Product: ${product.id}');
    await Future.delayed(_delay);
    
    // Simulate creation - add to mock data
    ProductMockData.products.add(product);
    
    logger.info('Successfully created Product: ${product.id}');
    return product;
  }

  @override
  Future<Product> update(UpdateParams<Product> params) async {
    logger.info('Updating Product: ${params.id}');
    await Future.delayed(_delay);
    
    final index = ProductMockData.products.indexWhere(
      (p) => p.id == params.id,
    );
    
    if (index == -1) {
      throw NotFoundFailure('Product not found: ${params.id}');
    }
    
    // Apply partial update
    final existing = ProductMockData.products[index];
    final updated = existing.copyWith(
      name: params.data['name'] as String?,
      price: params.data['price'] as double?,
    );
    
    ProductMockData.products[index] = updated;
    
    logger.info('Successfully updated Product: ${params.id}');
    return updated;
  }

  @override
  Future<void> delete(String id) async {
    logger.info('Deleting Product: $id');
    await Future.delayed(_delay);
    
    final removed = ProductMockData.products.removeWhere((p) => p.id == id);
    
    if (removed == 0) {
      throw NotFoundFailure('Product not found: $id');
    }
    
    logger.info('Successfully deleted Product: $id');
  }

  @override
  Stream<Product> watch(String id) {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      final item = ProductMockData.products.firstWhere(
        (item) => item.id == id,
        orElse: () => throw NotFoundFailure('Product not found: $id'),
      );
      return item;
    }).take(10); // Limit for demo
  }

  @override
  Stream<List<Product>> watchList() {
    return Stream.periodic(const Duration(seconds: 1), (_) {
      return ProductMockData.products;
    });
  }
}
```

## Features

### Type-Appropriate Mock Values

| Field Type | Generated Value |
|------------|-----------------|
| `String` | `'fieldName 1'`, `'fieldName 2'`, etc. |
| `int` | Sequential numbers (1, 2, 3...) |
| `double` | Decimal values (10.0, 20.0, 30.0...) |
| `bool` | Alternating true/false |
| `DateTime` | Recent dates with variations |
| `Enum` | Cycles through enum values |
| `List<T>` | Sample lists with 2-3 items |
| `Map<K,V>` | Sample key-value pairs |

### Nested Entity Support

Mock data automatically handles nested entities:

```dart
// Order entity with nested Customer and Product
class Order {
  final String id;
  final Customer customer;  // Nested entity
  final List<Product> items;  // List of nested entities
  final double total;
}

// Generated mock data includes nested entities
class OrderMockData {
  static final List<Order> orders = [
    Order(
      id: 'id 1',
      customer: CustomerMockData.customers[0],  // Reference to other mock
      items: [
        ProductMockData.products[0],
        ProductMockData.products[1],
      ],
      total: 79.98,
    ),
  ];
}
```

### Nullable Fields

Nullable fields get realistic null distribution:

```dart
Product(
  id: 'id 1',
  name: 'name 1',
  description: 'description 1',  // Sometimes null
  price: 29.99,
  category: null,  // Realistic nulls for optional fields
)
```

## Using Mock Data

### Development Mode

Use `--use-mock` with `--di` to register mock datasource:

```bash
zfa generate Product \
  --methods=get,getList,create,update,delete \
  --repository \
  --data \
  --vpc \
  --di \
  --use-mock
```

Generated DI:

```dart
void registerProductDataSources() {
  // Register mock instead of remote
  getIt.registerLazySingleton<ProductDataSource>(
    () => ProductMockDataSource(),
    instanceName: 'remote',
  );
}
```

### Environment-Based Switching

```dart
// lib/src/di/di.dart
void setupDI({bool useMock = false}) {
  if (useMock) {
    registerMockDataSources();
  } else {
    registerRemoteDataSources();
  }
  registerRepositories();
  registerUseCases();
}

// main.dart
void main() {
  const useMock = bool.fromEnvironment('USE_MOCK', defaultValue: false);
  setupDI(useMock: useMock);
  runApp(const MyApp());
}
```

Run with mock:

```bash
flutter run --dart-define=USE_MOCK=true
```

### Testing

Use mock data in unit tests:

```dart
group('ProductRepository', () {
  late ProductMockDataSource mockDataSource;
  late DataProductRepository repository;

  setUp(() {
    mockDataSource = ProductMockDataSource(delay: Duration.zero);
    repository = DataProductRepository(mockDataSource);
  });

  test('returns product from mock data', () async {
    final result = await repository.get('id 1');
    
    expect(result.id, equals('id 1'));
    expect(result.name, equals('name 1'));
  });

  test('returns all mock products', () async {
    final result = await repository.getList();
    
    expect(result.length, equals(3));
  });

  test('throws NotFoundFailure for unknown id', () async {
    expect(
      () => repository.get('unknown'),
      throwsA(isA<NotFoundFailure>()),
    );
  });
});
```

### UI Development

Use large datasets for performance testing:

```dart
class ProductListView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Use large list to test scrolling performance
    final products = ProductMockData.largeProductList;
    
    return ListView.builder(
      itemCount: products.length,
      itemBuilder: (context, index) {
        return ProductListItem(product: products[index]);
      },
    );
  }
}
```

### Demo Mode

Create a demo mode with simulated delays:

```dart
class DemoProductDataSource extends ProductMockDataSource {
  DemoProductDataSource() : super(
    delay: const Duration(milliseconds: 800),  // Simulate network
  );
}
```

## Mock Data Only

Generate just the mock data without the datasource:

```bash
zfa generate Product --mock-data-only
```

Useful when you want to:
- Use mock data in custom datasources
- Populate databases with test data
- Create fixtures for integration tests

## Best Practices

### 1. Use Mock for Early Development

Start with mock data, switch to real API later:

```bash
# Phase 1: UI development with mock
zfa generate Product --methods=get,getList --repository --data --mock --di --use-mock

# Phase 2: Switch to real API
# Just remove --use-mock and implement remote datasource
```

### 2. Customize Mock Data

Edit generated mock data for specific test scenarios:

```dart
class ProductMockData {
  static final List<Product> products = [
    // Add specific test cases
    Product(
      id: 'out-of-stock',
      name: 'Out of Stock Product',
      quantity: 0,  // Edge case
    ),
    Product(
      id: 'expensive',
      name: 'Very Expensive',
      price: 999999.99,  // Edge case
    ),
    ...// default generated items
  ];
}
```

### 3. Version Control

Commit mock data files - they're useful for:
- Consistent test data across team
- CI/CD pipelines
- Demo environments

### 4. Refresh Mock Data

Regenerate when entity changes:

```bash
# Force regenerate mock data
zfa generate Product --methods=get,getList --mock --force
```

## Troubleshooting

### Missing Enum Imports

If your entity uses enums, ensure they're in `lib/src/domain/entities/enums/`:

```
lib/src/domain/entities/
├── product/
│   └── product.dart
└── enums/
    ├── category.dart
    └── index.dart  # Export all enums
```

### Nested Entities Not Generated

Generate mock data for nested entities first:

```bash
# Generate Customer mock first (used by Order)
zfa generate Customer --methods=get --mock

# Then generate Order with nested references
zfa generate Order --methods=get --mock
```

---

## Next Steps

- [Dependency Injection](./dependency-injection) - DI setup with mock data
- [Testing](../guides/testing) - Testing with mock data
- [CLI Commands](../cli/commands) - All generation options