# UseCase Types

Zuraffa provides four UseCase types for different operation patterns. Each type is designed for specific use cases and provides optimal error handling and cancellation support.

## Overview

| UseCase Type | Returns | Use When | Generated By |
|--------------|---------|----------|--------------|
| [`UseCase<T, Params>`](#usecase) | `Future<Result<T, AppFailure>>` | Single-shot operations (CRUD, API calls) | `get`, `getList`, `create`, `update` |
| [`CompletableUseCase<Params>`](#completableusecase) | `Future<Result<void, AppFailure>>` | Operations without return value | `delete` |
| [`StreamUseCase<T, Params>`](#streamusecase) | `Stream<Result<T, AppFailure>>` | Real-time updates, reactive data | `watch`, `watchList` |
| [`BackgroundUseCase<T, Params>`](#backgroundusecase) | `Stream<Result<T, AppFailure>>` | CPU-intensive work on isolates | `--type=background` |

---

## UseCase

The default UseCase for single-shot operations that return a value.

### When to Use

- Fetching data from API
- Creating or updating entities
- Any operation that returns a single result

### Class Definition

```dart
abstract class UseCase<T, Params> {
  Future<Result<T, AppFailure>> call(
    Params params, {
    CancelToken? cancelToken,
  });
  
  @protected
  Future<T> execute(Params params, CancelToken? cancelToken);
}
```

### Example: GetProductUseCase

```dart
class GetProductUseCase extends UseCase<Product, String> {
  final ProductRepository _repository;
  
  GetProductUseCase(this._repository);
  
  @override
  Future<Product> execute(String id, CancelToken? cancelToken) async {
    // Check cancellation before starting
    cancelToken?.throwIfCancelled();
    
    // Perform the operation
    final product = await _repository.get(id);
    
    // Check cancellation after operation
    cancelToken?.throwIfCancelled();
    
    return product;
  }
}
```

### Usage

```dart
final getProductUseCase = GetProductUseCase(repository);

// Using call syntax
final result = await getProductUseCase('product-123');

// Handle result
result.fold(
  (product) => print('Got: ${product.name}'),
  (failure) => print('Error: ${failure.message}'),
);
```

### Generated Methods

| Method | UseCase Type | Params | Returns |
|--------|--------------|--------|---------|
| `get` | `UseCase` | `String id` | `Product` |
| `getList` | `UseCase` | `NoParams` | `List<Product>` |
| `create` | `UseCase` | `Product` | `Product` |
| `update` | `UseCase` | `UpdateParams<Product>` | `Product` |

---

## CompletableUseCase

For operations that complete but don't return a value (fire-and-forget).

### When to Use

- Delete operations
- Logout/sign out
- Clear cache
- Fire-and-forget analytics events
- Any operation where only success/failure matters

### Class Definition

```dart
abstract class CompletableUseCase<Params> extends UseCase<void, Params> {
  @override
  @protected
  Future<void> execute(Params params, CancelToken? cancelToken);
}
```

### Example: DeleteProductUseCase

```dart
class DeleteProductUseCase extends CompletableUseCase<String> {
  final ProductRepository _repository;
  
  DeleteProductUseCase(this._repository);
  
  @override
  Future<void> execute(String id, CancelToken? cancelToken) async {
    cancelToken?.throwIfCancelled();
    await _repository.delete(id);
  }
}
```

### Usage

```dart
final deleteProductUseCase = DeleteProductUseCase(repository);

final result = await deleteProductUseCase('product-123');

result.fold(
  (_) => print('Deleted successfully'),
  (failure) => print('Delete failed: ${failure.message}'),
);
```

### Generated Methods

| Method | UseCase Type | Params | Returns |
|--------|--------------|--------|---------|
| `delete` | `CompletableUseCase` | `String id` | `void` |

---

## StreamUseCase

For reactive operations that emit multiple values over time.

### When to Use

- Real-time data updates (Firebase, WebSocket)
- Watching for changes
- Pagination with continuous loading
- Long-running operations with progress updates

### Class Definition

```dart
abstract class StreamUseCase<T, Params> {
  Stream<Result<T, AppFailure>> call(
    Params params, {
    CancelToken? cancelToken,
  });
  
  @protected
  Stream<T> execute(Params params, CancelToken? cancelToken);
  
  // Convenience method with callbacks
  StreamSubscription<Result<T, AppFailure>> listen(
    Params params, {
    required void Function(T data) onData,
    void Function(AppFailure failure)? onError,
    void Function()? onDone,
    CancelToken? cancelToken,
  });
}
```

### Example: WatchProductUseCase

```dart
class WatchProductUseCase extends StreamUseCase<Product, String> {
  final ProductRepository _repository;
  
  WatchProductUseCase(this._repository);
  
  @override
  Stream<Product> execute(String id, CancelToken? cancelToken) {
    return _repository.watch(id);
  }
}
```

### Usage

```dart
final watchProductUseCase = WatchProductUseCase(repository);

// Using stream
watchProductUseCase('product-123').listen((result) {
  result.fold(
    (product) => updateUI(product),
    (failure) => showError(failure),
  );
});

// Using listen helper
final subscription = watchProductUseCase.listen(
  'product-123',
  onData: (product) => updateUI(product),
  onError: (failure) => showError(failure),
  onDone: () => print('Stream closed'),
);

// Cancel when done
subscription.cancel();
```

### Generated Methods

| Method | UseCase Type | Params | Returns |
|--------|--------------|--------|---------|
| `watch` | `StreamUseCase` | `String id` | `Product` |
| `watchList` | `StreamUseCase` | `NoParams` | `List<Product>` |

---

## BackgroundUseCase

For CPU-intensive operations that run on a separate isolate to avoid blocking the UI thread.

:::warning Web Not Supported
BackgroundUseCase is **not supported on web** platforms. Use regular `UseCase` with `compute()` for simple cases on web.
:::

### When to Use

- Image processing (filters, compression)
- Large data parsing (JSON, XML, CSV)
- Complex mathematical calculations
- Encryption/decryption
- Machine learning inference

### Class Definition

```dart
abstract class BackgroundUseCase<T, Params> {
  BackgroundUseCaseState get state;
  bool get isRunning;
  
  Stream<Result<T, AppFailure>> call(
    Params params, {
    CancelToken? cancelToken,
  });
  
  @protected
  BackgroundTask<Params> buildTask();
}

// Task function signature
typedef BackgroundTask<Params> = FutureOr<void> Function(
  BackgroundTaskContext<Params> context,
);

// Context for sending data back
class BackgroundTaskContext<Params> {
  void sendData<T>(T data);
  void sendError(Object error, [StackTrace? stackTrace]);
  void sendDone();
}
```

### Example: ProcessImageUseCase

```dart
class ProcessImageUseCase extends BackgroundUseCase<ProcessedImage, ImageParams> {
  @override
  BackgroundTask<ImageParams> buildTask() => _processImage;
  
  // MUST be static or top-level function
  static void _processImage(BackgroundTaskContext<ImageParams> context) {
    try {
      final params = context.params;
      
      // CPU-intensive work
      final processed = applyFilters(params.image);
      final compressed = compressImage(processed);
      
      // Send result back
      context.sendData(ProcessedImage(compressed));
      context.sendDone();
    } catch (e, stackTrace) {
      context.sendError(e, stackTrace);
    }
  }
}
```

### Usage

```dart
final processImageUseCase = ProcessImageUseCase();

// Listen to progress
processImageUseCase(ImageParams(image: rawImage)).listen((result) {
  result.fold(
    (processed) => saveImage(processed),
    (failure) => showError(failure),
  );
});

// Check state
print(processImageUseCase.state); // idle, loading, calculating
print(processImageUseCase.isRunning); // true/false
```

### Important Constraints

1. **Static or Top-Level Functions Only**: The task function must be static or top-level (not closures or instance methods)
2. **Serializable Parameters**: Parameters must be primitives, Lists, or Maps
3. **No Web Support**: Throws assertion error on web platforms

### Generated via CLI

```bash
zfa generate ProcessImages \
  --type=background \
  --params=ImageBatch \
  --returns=ProcessedImage
```

---

## Error Handling

All UseCases handle errors consistently:

```dart
// All UseCases return Result<T, AppFailure>
final result = await someUseCase(params);

// Pattern matching on result
switch (result) {
  case Success(:final value):
    handleSuccess(value);
  case Failure(:final error):
    handleFailure(error);
}

// Or using fold
result.fold(
  (value) => handleSuccess(value),
  (failure) => handleFailure(failure),
);
```

### Automatic Error Wrapping

| Exception Type | Converted To |
|----------------|--------------|
| `AppFailure` | Passed through as-is |
| `CancelledException` | `CancellationFailure` |
| Any other exception | `UnknownFailure` |

---

## Cancellation

All UseCases support cooperative cancellation via `CancelToken`:

```dart
final cancelToken = CancelToken();

// Start operation
final future = getProductUseCase('id', cancelToken: cancelToken);

// Cancel later
cancelToken.cancel('User navigated away');

// Result will be CancellationFailure
final result = await future;
result.fold(
  (product) => {},
  (failure) => print(failure is CancellationFailure), // true
);
```

### Cancellation Points

Place cancellation checks at strategic points:

```dart
@override
Future<Data> execute(Params params, CancelToken? cancelToken) async {
  // Before starting
  cancelToken?.throwIfCancelled();
  
  final step1 = await doStep1();
  
  // Between steps
  cancelToken?.throwIfCancelled();
  
  final step2 = await doStep2();
  
  // After long operations
  cancelToken?.throwIfCancelled();
  
  return processResults(step1, step2);
}
```

---

## Custom UseCases

Create custom UseCases for complex business operations:

```bash
zfa generate ProcessCheckout \
  --repos=CartRepository,OrderRepository,PaymentRepository \
  --params=CheckoutRequest \
  --returns=OrderConfirmation
```

Generates:

```dart
class ProcessCheckoutUseCase extends UseCase<OrderConfirmation, CheckoutRequest> {
  final CartRepository _cartRepository;
  final OrderRepository _orderRepository;
  final PaymentRepository _paymentRepository;
  
  ProcessCheckoutUseCase(
    this._cartRepository,
    this._orderRepository,
    this._paymentRepository,
  );
  
  @override
  Future<OrderConfirmation> execute(
    CheckoutRequest request,
    CancelToken? cancelToken,
  ) async {
    cancelToken?.throwIfCancelled();
    
    // Validate cart
    final cart = await _cartRepository.get(request.cartId);
    
    cancelToken?.throwIfCancelled();
    
    // Process payment
    final payment = await _paymentRepository.charge(
      cart.total,
      request.paymentMethod,
    );
    
    cancelToken?.throwIfCancelled();
    
    // Create order
    final order = await _orderRepository.create(
      CreateOrderRequest(
        cart: cart,
        payment: payment,
      ),
    );
    
    // Clear cart
    await _cartRepository.clear(request.cartId);
    
    return OrderConfirmation(order: order, payment: payment);
  }
}
```

---

## Best Practices

### 1. One UseCase = One Operation

```dart
// Good: Single responsibility
class GetProductUseCase extends UseCase<Product, String> { ... }
class UpdateProductUseCase extends UseCase<Product, UpdateParams> { ... }

// Bad: Multiple responsibilities
class ProductUseCase extends UseCase<dynamic, dynamic> {
  // Handles get, update, delete... too much!
}
```

### 2. Use Meaningful Parameter Types

```dart
// Good: Type-safe parameters
class CreateOrderParams {
  final Cart cart;
  final PaymentMethod payment;
  final Address shippingAddress;
  
  const CreateOrderParams({...});
}

// Bad: Unclear parameters
class CreateOrderUseCase extends UseCase<Order, Map<String, dynamic>> { ... }
```

### 3. Handle Cancellation at Key Points

```dart
@override
Future<Data> execute(Params params, CancelToken? cancelToken) async {
  cancelToken?.throwIfCancelled();
  
  final data = await fetchData();
  
  // Before expensive processing
  cancelToken?.throwIfCancelled();
  
  final processed = expensiveProcessing(data);
  
  // Before saving
  cancelToken?.throwIfCancelled();
  
  return await save(processed);
}
```

### 4. Don't Catch Exceptions Unnecessarily

```dart
// Good: Let UseCase handle errors
@override
Future<Product> execute(String id, CancelToken? cancelToken) async {
  return await _repository.get(id); // Errors auto-wrapped
}

// Bad: Unnecessary try-catch
@override
Future<Product> execute(String id, CancelToken? cancelToken) async {
  try {
    return await _repository.get(id);
  } catch (e) {
    // Don't do this - UseCase already handles it
    throw AppFailure.unknown(e.toString());
  }
}
```

---

## Next Steps

- [Result Type](./result-type) - Deep dive into error handling
- [CLI Reference](../cli/commands) - Generate UseCases automatically
- [VPC Pattern](./vpc-pattern) - Connect UseCases to UI