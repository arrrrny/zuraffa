# UseCase Types

Zuraffa provides four UseCase types for different operation patterns. Each type is designed for specific use cases and provides optimal error handling and cancellation support.

## Overview

| UseCase Type | Returns | Use When | Generated By |
|--------------|---------|----------|--------------|
| [`UseCase<T, Params>`](#usecase) | `Future<Result<T, AppFailure>>` | Single-shot operations (CRUD, API calls) | `get`, `getList`, `create`, `update` |
| [`CompletableUseCase<Params>`](#completableusecase) | `Future<Result<void, AppFailure>>` | Operations without return value | `delete` |
| [`StreamUseCase<T, Params>`](#streamusecase) | `Stream<Result<T, AppFailure>>` | Real-time updates, reactive data | `watch`, `watchList` |
| [`BackgroundUseCase<T, Params>`](#backgroundusecase) | `Stream<Result<T, AppFailure>>` | CPU-intensive work on isolates | `--type=background` |

---

## ZFA Patterns

ZFA introduces four powerful patterns for organizing your business logic:

### 1. Entity-Based Pattern

Perfect for standard CRUD operations on entities. Automatically generates all layers.

```bash
zfa generate Product \
  --methods=get,getList,create,update,delete,watch,watchList \
  --data \
  --vpc \
  --state \
  --test \
  --cache \
  --di
```

**Characteristics:**
- Generates complete CRUD stack
- Follows convention-based naming
- Automatically creates repository, usecases, data layer, and presentation layer
- Ideal for domain entities (Product, User, Order, etc.)

### 2. Single Repository Pattern (Recommended)

Best for custom business logic with one repository to enforce Single Responsibility Principle.

```bash
zfa generate ProcessCheckout \
  --domain=checkout \
  --repo=CheckoutRepository \
  --params=CheckoutRequest \
  --returns=OrderConfirmation
```

**Characteristics:**
- One UseCase, one repository
- Enforces Single Responsibility Principle
- Organized by domain concepts
- Requires `--domain` and `--repo` flags

### 3. Orchestrator Pattern (NEW)

Compose multiple UseCases into complex workflows.

```bash
# Step 1: Create atomic UseCases
zfa generate ValidateCart --domain=checkout --repo=Cart --params=CartId --returns=bool
zfa generate CreateOrder --domain=checkout --repo=Order --params=OrderData --returns=Order
zfa generate ProcessPayment --domain=checkout --repo=Payment --params=PaymentData --returns=Receipt

# Step 2: Orchestrate them
zfa generate ProcessCheckout \
  --domain=checkout \
  --usecases=ValidateCart,CreateOrder,ProcessPayment \
  --params=CheckoutRequest \
  --returns=Order
```

**Characteristics:**
- Composes multiple UseCases
- No direct repository injection
- Perfect for complex business flows
- Requires `--usecases`, `--domain`, `--params`, and `--returns`

### 4. Polymorphic Pattern (NEW)

Generate abstract base + concrete variants + factory.

```bash
zfa generate SparkSearch \
  --domain=search \
  --repo=Search \
  --variants=Barcode,Url,Text \
  --params=Spark \
  --returns=Listing \
  --type=stream
```

**Characteristics:**
- Generates abstract base class
- Creates concrete implementations for each variant
- Provides factory for runtime switching
- Requires `--variants`, `--domain`, `--params`, and `--returns`

---

## UseCase

The default UseCase for single-shot operations that return a value.

### When to Use

- Fetching data from API
- Creating or updating entities
- Any operation that returns a single result

### Class Definition

```dart
abstract class UseCase<T, Params> {
  Future<Result<T, AppFailure>> call(
    Params params, {
    CancelToken? cancelToken,
  });

  @protected
  Future<T> execute(Params params, CancelToken? cancelToken);
}
```

### Example: GetProductUseCase

```dart
class GetProductUseCase extends UseCase<Product, String> {
  final ProductRepository _repository;

  GetProductUseCase(this._repository);

  @override
  Future<Product> execute(String id, CancelToken? cancelToken) async {
    // Check cancellation before starting
    cancelToken?.throwIfCancelled();

    // Perform the operation
    final product = await _repository.get(id);

    // Check cancellation after operation
    cancelToken?.throwIfCancelled();

    return product;
  }
}
```

### Usage

```dart
final getProductUseCase = GetProductUseCase(repository);

// Using call syntax
final result = await getProductUseCase('product-123');

// Handle result
result.fold(
  (product) => print('Got: ${product.name}'),
  (failure) => print('Error: ${failure.message}'),
);
```

### Generated Methods

| Method | UseCase Type | Params | Returns |
|--------|--------------|--------|---------|
| `get` | `UseCase` | `String id` | `Product` |
| `getList` | `UseCase` | `NoParams` | `List<Product>` |
| `create` | `UseCase` | `Product` | `Product` |
| `update` | `UseCase` | `UpdateParams<Product>` | `Product` |

---

## CompletableUseCase

For operations that complete but don't return a value (fire-and-forget).

### When to Use

- Delete operations
- Logout/sign out
- Clear cache
- Fire-and-forget analytics events
- Any operation where only success/failure matters

### Class Definition

```dart
abstract class CompletableUseCase<Params> extends UseCase<void, Params> {
  @override
  @protected
  Future<void> execute(Params params, CancelToken? cancelToken);
}
```

### Example: DeleteProductUseCase

```dart
class DeleteProductUseCase extends CompletableUseCase<String> {
  final ProductRepository _repository;

  DeleteProductUseCase(this._repository);

  @override
  Future<void> execute(String id, CancelToken? cancelToken) async {
    cancelToken?.throwIfCancelled();
    await _repository.delete(id);
  }
}
```

### Usage

```dart
final deleteProductUseCase = DeleteProductUseCase(repository);

final result = await deleteProductUseCase('product-123');

result.fold(
  (_) => print('Deleted successfully'),
  (failure) => print('Delete failed: ${failure.message}'),
);
```

### Generated Methods

| Method | UseCase Type | Params | Returns |
|--------|--------------|--------|---------|
| `delete` | `CompletableUseCase` | `String id` | `void` |

---

## StreamUseCase

For reactive operations that emit multiple values over time.

### When to Use

- Real-time data updates (Firebase, WebSocket)
- Watching for changes
- Pagination with continuous loading
- Long-running operations with progress updates

### Class Definition

```dart
abstract class StreamUseCase<T, Params> {
  Stream<Result<T, AppFailure>> call(
    Params params, {
    CancelToken? cancelToken,
  });

  @protected
  Stream<T> execute(Params params, CancelToken? cancelToken);

  // Convenience method with callbacks
  StreamSubscription<Result<T, AppFailure>> listen(
    Params params, {
    required void Function(T data) onData,
    void Function(AppFailure failure)? onError,
    void Function()? onDone,
    CancelToken? cancelToken,
  });
}
```

### Example: WatchProductUseCase

```dart
class WatchProductUseCase extends StreamUseCase<Product, String> {
  final ProductRepository _repository;

  WatchProductUseCase(this._repository);

  @override
  Stream<Product> execute(String id, CancelToken? cancelToken) {
    return _repository.watch(id);
  }
}
```

### Usage

```dart
final watchProductUseCase = WatchProductUseCase(repository);

// Using stream
watchProductUseCase('product-123').listen((result) {
  result.fold(
    (product) => updateUI(product),
    (failure) => showError(failure),
  );
});

// Using listen helper
final subscription = watchProductUseCase.listen(
  'product-123',
  onData: (product) => updateUI(product),
  onError: (failure) => showError(failure),
  onDone: () => print('Stream closed'),
);

// Cancel when done
subscription.cancel();
```

### Generated Methods

| Method | UseCase Type | Params | Returns |
|--------|--------------|--------|---------|
| `watch` | `StreamUseCase` | `String id` | `Product` |
| `watchList` | `StreamUseCase` | `NoParams` | `List<Product>` |

---

## BackgroundUseCase

For CPU-intensive operations that run on a separate isolate to avoid blocking the UI thread.

:::warning Web Not Supported
BackgroundUseCase is **not supported on web** platforms. Use regular `UseCase` with `compute()` for simple cases on web.
:::

### When to Use

- Image processing (filters, compression)
- Large data parsing (JSON, XML, CSV)
- Complex mathematical calculations
- Encryption/decryption
- Machine learning inference

### Class Definition

```dart
abstract class BackgroundUseCase<T, Params> {
  BackgroundUseCaseState get state;
  bool get isRunning;

  Stream<Result<T, AppFailure>> call(
    Params params, {
    CancelToken? cancelToken,
  });

  @protected
  BackgroundTask<Params> buildTask();
}

// Task function signature
typedef BackgroundTask<Params> = FutureOr<void> Function(
  BackgroundTaskContext<Params> context,
);

// Context for sending data back
class BackgroundTaskContext<Params> {
  void sendData<T>(T data);
  void sendError(Object error, [StackTrace? stackTrace]);
  void sendDone();
}
```

### Example: ProcessImageUseCase

```dart
class ProcessImageUseCase extends BackgroundUseCase<ProcessedImage, ImageParams> {
  @override
  BackgroundTask<ImageParams> buildTask() => _processImage;

  // MUST be static or top-level function
  static void _processImage(BackgroundTaskContext<ImageParams> context) {
    try {
      final params = context.params;

      // CPU-intensive work
      final processed = applyFilters(params.image);
      final compressed = compressImage(processed);

      // Send result back
      context.sendData(ProcessedImage(compressed));
      context.sendDone();
    } catch (e, stackTrace) {
      context.sendError(e, stackTrace);
    }
  }
}
```

### Usage

```dart
final processImageUseCase = ProcessImageUseCase();

// Listen to progress
processImageUseCase(ImageParams(image: rawImage)).listen((result) {
  result.fold(
    (processed) => saveImage(processed),
    (failure) => showError(failure),
  );
});

// Check state
print(processImageUseCase.state); // idle, loading, calculating
print(processImageUseCase.isRunning); // true/false
```

### Important Constraints

1. **Static or Top-Level Functions Only**: The task function must be static or top-level (not closures or instance methods)
2. **Serializable Parameters**: Parameters must be primitives, Lists, or Maps
3. **No Web Support**: Throws assertion error on web platforms

### Generated via CLI

```bash
zfa generate ProcessImages \
  --domain=image \
  --repo=ImageProcessor \
  --type=background \
  --params=ImageBatch \
  --returns=ProcessedImage
```

---

## Error Handling

All UseCases handle errors consistently:

```dart
// All UseCases return Result<T, AppFailure>
final result = await someUseCase(params);

// Pattern matching on result
switch (result) {
  case Success(:final value):
    handleSuccess(value);
  case Failure(:final error):
    handleFailure(error);
}

// Or using fold
result.fold(
  (value) => handleSuccess(value),
  (failure) => handleFailure(failure),
);
```

### Automatic Error Wrapping

| Exception Type | Converted To |
|----------------|--------------|
| `AppFailure` | Passed through as-is |
| `CancelledException` | `CancellationFailure` |
| Any other exception | `UnknownFailure` |

---

## Cancellation

All UseCases support cooperative cancellation via `CancelToken`:

```dart
final cancelToken = CancelToken();

// Start operation
final future = getProductUseCase('id', cancelToken: cancelToken);

// Cancel later
cancelToken.cancel('User navigated away');

// Result will be CancellationFailure
final result = await future;
result.fold(
  (product) => {},
  (failure) => print(failure is CancellationFailure), // true
);
```

### Cancellation Points

Place cancellation checks at strategic points:

```dart
@override
Future<Data> execute(Params params, CancelToken? cancelToken) async {
  // Before starting
  cancelToken?.throwIfCancelled();

  final step1 = await doStep1();

  // Between steps
  cancelToken?.throwIfCancelled();

  final step2 = await doStep2();

  // After long operations
  cancelToken?.throwIfCancelled();

  return processResults(step1, step2);
}
```

---

## Custom UseCases with ZFA Patterns

### Single Repository Pattern

Create custom UseCases with one repository for focused business logic:

```bash
zfa generate ProcessCheckout \
  --domain=checkout \
  --repo=CheckoutRepository \
  --params=CheckoutRequest \
  --returns=OrderConfirmation
```

Generates:

```dart
class ProcessCheckoutUseCase extends UseCase<OrderConfirmation, CheckoutRequest> {
  final CheckoutRepository _checkoutRepository;

  ProcessCheckoutUseCase(this._checkoutRepository);

  @override
  Future<OrderConfirmation> execute(
    CheckoutRequest request,
    CancelToken? cancelToken,
  ) async {
    cancelToken?.throwIfCancelled();

    // Business logic using single repository
    final result = await _checkoutRepository.process(request);

    return result;
  }
}
```

### Orchestrator Pattern

Compose multiple UseCases into complex workflows:

```bash
zfa generate ProcessCheckout \
  --domain=checkout \
  --usecases=ValidateCart,CreateOrder,ProcessPayment \
  --params=CheckoutRequest \
  --returns=OrderConfirmation
```

Generates:

```dart
class ProcessCheckoutUseCase extends UseCase<OrderConfirmation, CheckoutRequest> {
  final ValidateCartUseCase _validateCart;
  final CreateOrderUseCase _createOrder;
  final ProcessPaymentUseCase _processPayment;

  ProcessCheckoutUseCase(
    this._validateCart,
    this._createOrder,
    this._processPayment,
  );

  @override
  Future<OrderConfirmation> execute(
    CheckoutRequest request,
    CancelToken? cancelToken,
  ) async {
    cancelToken?.throwIfCancelled();

    // Orchestrate multiple UseCases
    final isValid = await _validateCart.execute(request.cartId, cancelToken);
    if (isValid.isFailure) return Result.failure(isValid.failure);

    final order = await _createOrder.execute(request.orderData, cancelToken);
    if (order.isFailure) return Result.failure(order.failure);

    final payment = await _processPayment.execute(request.paymentData, cancelToken);
    if (payment.isFailure) return Result.failure(payment.failure);

    return Result.success(OrderConfirmation(order: order.success, payment: payment.success));
  }
}
```

### Polymorphic Pattern

Generate multiple implementations of the same operation:

```bash
zfa generate SparkSearch \
  --domain=search \
  --repo=Search \
  --variants=Barcode,Url,Text \
  --params=Spark \
  --returns=Listing \
  --type=stream
```

Generates:
- Abstract base: `SparkSearchUseCase`
- Concrete implementations: `BarcodeSparkSearchUseCase`, `UrlSparkSearchUseCase`, `TextSparkSearchUseCase`
- Factory: `SparkSearchUseCaseFactory`

---

## Best Practices

### 1. Choose the Right Pattern

```bash
# Entity-Based: For standard CRUD on domain entities
zfa generate Product --methods=get,getList,create,update,delete --data --vpc

# Single Repository: For focused business logic
zfa generate ProcessCheckout --domain=checkout --repo=Checkout --params=Request --returns=Result

# Orchestrator: For complex workflows
zfa generate ProcessCheckout --domain=checkout --usecases=ValidateCart,CreateOrder,ProcessPayment --params=Request --returns=Result

# Polymorphic: For multiple implementations of same operation
zfa generate SparkSearch --domain=search --variants=Barcode,Url,Text --params=Spark --returns=Listing
```

### 2. Use Domain Organization

Organize UseCases by domain concepts:

```bash
zfa generate SearchProduct \
  --domain=search \
  --repo=Product \
  --params=Query \
  --returns=List<Product>
```

### 3. One UseCase = One Operation

```dart
// Good: Single responsibility
class GetProductUseCase extends UseCase<Product, String> { ... }
class UpdateProductUseCase extends UseCase<Product, UpdateParams> { ... }

// Bad: Multiple responsibilities
class ProductUseCase extends UseCase<dynamic, dynamic> {
  // Handles get, update, delete... too much!
}
```

### 4. Use Meaningful Parameter Types

```dart
// Good: Type-safe parameters
class CreateOrderParams {
  final Cart cart;
  final PaymentMethod payment;
  final Address shippingAddress;

  const CreateOrderParams({...});
}

// Bad: Unclear parameters
class CreateOrderUseCase extends UseCase<Order, Map<String, dynamic>> { ... }
```

### 5. Handle Cancellation at Key Points

```dart
@override
Future<Data> execute(Params params, CancelToken? cancelToken) async {
  cancelToken?.throwIfCancelled();

  final data = await fetchData();

  // Before expensive processing
  cancelToken?.throwIfCancelled();

  final processed = expensiveProcessing(data);

  // Before saving
  cancelToken?.throwIfCancelled();

  return await save(processed);
}
```

---

## Next Steps

- [Architecture Overview](../architecture/overview) - Deep dive into Clean Architecture patterns
- [Result Type](../architecture/result-type) - Type-safe error handling
- [CLI Reference](../cli/commands) - Generate UseCases automatically