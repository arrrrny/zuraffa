// Generated by zfa
// zfa generate Product --methods=get,getList,watch,watchList,create,update,delete --vpc --state

import 'package:zuraffa/zuraffa.dart';
import 'product_presenter.dart';
import 'product_state.dart';
import '../../../domain/entities/product/product.dart';

class ProductController extends Controller
    with StatefulController<ProductState> {
  final ProductPresenter _presenter;

  ProductController(this._presenter) : super();

  @override
  ProductState createInitialState() => const ProductState();

  Future<void> getProduct(String id) async {
    updateState(viewState.copyWith(isGetting: true));
    final result = await _presenter.getProduct(id);

    result.fold(
      (entity) => updateState(viewState.copyWith(
        isGetting: false,
        product: entity,
      )),
      (failure) => updateState(viewState.copyWith(
        isGetting: false,
        error: failure,
      )),
    );
  }

  Future<void> getProductList(
      [ListQueryParams<Product> params = const ListQueryParams()]) async {
    updateState(viewState.copyWith(isGettingList: true));
    final result = await _presenter.getProductList(params);

    result.fold(
      (list) => updateState(viewState.copyWith(
        isGettingList: false,
        productList: list,
      )),
      (failure) => updateState(viewState.copyWith(
        isGettingList: false,
        error: failure,
      )),
    );
  }

  void watchProduct(String id) {
    updateState(viewState.copyWith(isWatching: true));
    _presenter.watchProduct(id).listen(
      (result) {
        result.fold(
          (entity) => updateState(viewState.copyWith(
            isWatching: false,
            product: entity,
          )),
          (failure) => updateState(viewState.copyWith(
            isWatching: false,
            error: failure,
          )),
        );
      },
    );
  }

  void watchProductList(
      [ListQueryParams<Product> params = const ListQueryParams()]) {
    updateState(viewState.copyWith(isWatchingList: true));
    _presenter.watchProductList(params).listen(
      (result) {
        result.fold(
          (list) => updateState(viewState.copyWith(
            isWatchingList: false,
            productList: list,
          )),
          (failure) => updateState(viewState.copyWith(
            isWatchingList: false,
            error: failure,
          )),
        );
      },
    );
  }

  Future<void> createProduct(Product product) async {
    updateState(viewState.copyWith(isCreating: true));
    final result = await _presenter.createProduct(product);

    result.fold(
      (created) => updateState(viewState.copyWith(
        isCreating: false,
      )),
      (failure) => updateState(viewState.copyWith(
        isCreating: false,
        error: failure,
      )),
    );
  }

  Future<void> updateProduct(String id, Partial<Product> data) async {
    updateState(viewState.copyWith(isUpdating: true));
    final result = await _presenter.updateProduct(id, data);

    result.fold(
      (updated) => updateState(viewState.copyWith(
        isUpdating: false,
        product:
            viewState.product?.id == updated.id ? updated : viewState.product,
      )),
      (failure) => updateState(viewState.copyWith(
        isUpdating: false,
        error: failure,
      )),
    );
  }

  Future<void> deleteProduct(String id) async {
    // Immediately remove from list for optimistic UI update
    // This prevents Dismissible error where widget must be removed synchronously
    updateState(viewState.copyWith(
      isDeleting: true,
      productList: viewState.productList.where((e) => e.id != id).toList(),
    ));

    final result = await _presenter.deleteProduct(id);

    result.fold(
      (_) => updateState(viewState.copyWith(isDeleting: false)),
      (failure) => updateState(viewState.copyWith(
        isDeleting: false,
        error: failure,
      )),
    );
  }

  @override
  void onDisposed() {
    _presenter.dispose();
    super.onDisposed();
  }
}
