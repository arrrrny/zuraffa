// Generated by zfa
// Mock data source for Product

import 'dart:async';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/product/product.dart';
import '../../mock/product_mock_data.dart';
import 'product_data_source.dart';

class ProductMockDataSource
    with Loggable, FailureHandler
    implements ProductDataSource {
  final Duration _delay;

  ProductMockDataSource({Duration? delay})
      : _delay = delay ?? const Duration(milliseconds: 100);

  @override
  Future<Product> get(QueryParams<Product> params) async {
    logger.info('Getting Product with params: $params');
    await Future.delayed(_delay);
    final item = ProductMockData.products.query(params);
    logger.info('Successfully retrieved Product');
    return item;
  }

  @override
  Future<List<Product>> getList(ListQueryParams<Product> params) async {
    logger.info('Getting Product list with params: $params');
    await Future.delayed(_delay);
    var items = ProductMockData.products;

    // Apply limit if specified
    if (params.limit != null && params.limit! > 0) {
      items = items.take(params.limit!).toList();
    }

    logger.info('Successfully retrieved ${items.length} Products');
    return items;
  }

  @override
  Stream<Product> watch(QueryParams<Product> params) {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      final item = ProductMockData.products.query(params);
      return item;
    }).take(10); // Limit for demo
  }

  @override
  Stream<List<Product>> watchList(ListQueryParams<Product> params) {
    return Stream.periodic(const Duration(seconds: 2), (count) {
      var items = ProductMockData.products;
      if (params.limit != null && params.limit! > 0) {
        items = items.take(params.limit!).toList();
      }
      return items;
    }).take(5); // Limit for demo
  }

  @override
  Future<Product> create(Product item) async {
    logger.info('Creating Product: ${item.id}');
    await Future.delayed(_delay);
    // In a real implementation, you'd add to storage
    logger.info('Successfully created Product: ${item.id}');
    return item;
  }

  @override
  Future<Product> update(
      UpdateParams<Product, Map<String, dynamic>> params) async {
    logger.info('Updating Product with id: ${params.id}');
    await Future.delayed(_delay);
    final existing = ProductMockData.products.firstWhere(
      (item) => item.id == params.id,
      orElse: () => throw notFoundFailure('Product not found'),
    );
    // In a real implementation, you'd apply the update
    logger.info('Successfully updated Product');
    return existing;
  }

  @override
  Future<void> delete(DeleteParams<Product> params) async {
    logger.info('Deleting Product with id: ${params.id}');
    await Future.delayed(_delay);
    final exists = ProductMockData.products.any((item) => item.id == params.id);
    if (!exists) {
      throw notFoundFailure('Product not found');
    }
    // In a real implementation, you'd remove from storage
    logger.info('Successfully deleted Product');
  }
}
