// Generated by zfa
// Mock data source for Product

import 'dart:async';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/product/product.dart';
import '../../mock/product_mock_data.dart';
import 'product_data_source.dart';

class ProductMockDataSource
    with Loggable, FailureHandler
    implements ProductDataSource {
  final Duration _delay;

  ProductMockDataSource({Duration? delay})
      : _delay = delay ?? const Duration(milliseconds: 100);

  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing ProductMockDataSource');
    // Mock initialization - nothing to do
    await Future.delayed(const Duration(seconds: 1));
    logger.info('ProductMockDataSource initialized');
  }

  @override
  Stream<bool> get isInitialized => Stream.value(true);

  @override
  Future<Product> get(String id) async {
    logger.info('Getting Product with id: $id');
    await Future.delayed(_delay);
    final item = ProductMockData.products.firstWhere(
      (item) => item.id == id,
      orElse: () => throw NotFoundFailure('Product not found: $id'),
    );
    logger.info('Successfully retrieved Product: $id');
    return item;
  }

  @override
  Future<List<Product>> getList(ListQueryParams params) async {
    logger.info('Getting Product list with params: $params');
    await Future.delayed(_delay);
    var items = ProductMockData.products;

    // Apply limit if specified
    if (params.limit != null && params.limit! > 0) {
      items = items.take(params.limit!).toList();
    }

    logger.info('Successfully retrieved ${items.length} Products');
    return items;
  }

  @override
  Future<Product> create(Product item) async {
    logger.info('Creating Product: ${item.id}');
    await Future.delayed(_delay);
    // In a real implementation, you'd add to storage
    logger.info('Successfully created Product: ${item.id}');
    return item;
  }

  @override
  Stream<Product> watch(String id) {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      final item = ProductMockData.products.firstWhere(
        (item) => item.id == id,
        orElse: () => throw NotFoundFailure('Product not found: $id'),
      );
      return item;
    }).take(10); // Limit for demo
  }

  @override
  Future<Product> update(UpdateParams<Partial<Product>> params) async {
    logger.info('Updating Product: ${params.id} with data: ${params.data}');
    await Future.delayed(_delay);
    final existing = ProductMockData.products.firstWhere(
      (item) => item.id == params.id,
      orElse: () => throw NotFoundFailure('Product not found: ${params.id}'),
    );
    // In a real implementation, you'd apply the update
    logger.info('Successfully updated Product: ${params.id}');
    return existing;
  }

  @override
  Future<void> delete(DeleteParams<Product> params) async {
    logger.info('Deleting Product: ${params.id}');
    await Future.delayed(_delay);
    final exists = ProductMockData.products.any((item) => item.id == params.id);
    if (!exists) {
      throw NotFoundFailure('Product not found: ${params.id}');
    }
    // In a real implementation, you'd remove from storage
    logger.info('Successfully deleted Product: ${params.id}');
  }

  @override
  Stream<List<Product>> watchList(ListQueryParams params) {
    return Stream.periodic(const Duration(seconds: 2), (count) {
      var items = ProductMockData.products;
      if (params.limit != null && params.limit! > 0) {
        items = items.take(params.limit!).toList();
      }
      return items;
    }).take(5); // Limit for demo
  }
}
