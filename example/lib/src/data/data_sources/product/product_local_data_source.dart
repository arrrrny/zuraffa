// Generated by zfa
// zfa generate Product --methods=get,getList,watch,watchList,create,update,delete --data --cache --cache-storage=hive

import 'package:hive_ce_flutter/hive_ce_flutter.dart';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/product/product.dart';
import 'product_data_source.dart';

/// Local data source for Product using Hive.
class ProductLocalDataSource
    with Loggable, FailureHandler
    implements ProductDataSource {
  final Box<Product> _box;

  ProductLocalDataSource(this._box);

  Future<Product> save(Product product) async {
    await _box.put(product.id, product);
    return product;
  }

  Future<void> saveAll(List<Product> items) async {
    final map = {for (var item in items) item.id: item};
    await _box.putAll(map);
  }

  Future<void> clear() async {
    await _box.clear();
  }

  @override
  Future<Product> get(QueryParams<Product> params) async {
    return _box.values.query(params);
  }

  @override
  Future<List<Product>> getList(ListQueryParams<Product> params) async {
    return _box.values.filter(params.filter).orderBy(params.sort);
  }

  @override
  Stream<Product> watch(QueryParams<Product> params) {
    return _box.watch().map((_) => _box.values.query(params));
  }

  @override
  Stream<List<Product>> watchList(ListQueryParams<Product> params) {
    return _box
        .watch()
        .map((_) => _box.values.filter(params.filter).orderBy(params.sort));
  }

  @override
  Future<Product> create(Product product) async {
    await _box.put(product.id, product);
    return product;
  }

  @override
  Future<Product> update(
      UpdateParams<Product, Map<String, dynamic>> params) async {
    final existing = _box.values.firstWhere(
      (item) => item.id == params.id,
      orElse: () => throw notFoundFailure('Product not found in cache'),
    );
    // TODO: Apply Map<String, dynamic> patch to existing entity
    await _box.put(existing.id, existing);
    return existing;
  }

  @override
  Future<void> delete(DeleteParams<Product> params) async {
    final existing = _box.values.firstWhere(
      (item) => item.id == params.id,
      orElse: () => throw notFoundFailure('Product not found in cache'),
    );
    await _box.delete(existing.id);
  }
}
