// Generated by zfa
// Mock data source for Todo

import 'dart:async';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/todo/todo.dart';
import '../../mock/todo_mock_data.dart';
import 'todo_data_source.dart';

class TodoMockDataSource
    with Loggable, FailureHandler
    implements TodoDataSource {
  final Duration _delay;

  TodoMockDataSource({Duration? delay})
      : _delay = delay ?? const Duration(milliseconds: 100);

  @override
  Future<Todo> get(QueryParams<Todo> params) async {
    logger.info('Getting Todo with params: $params');
    await Future.delayed(_delay);
    final item = TodoMockData.todos.query(params);
    logger.info('Successfully retrieved Todo');
    return item;
  }

  @override
  Future<List<Todo>> getList(ListQueryParams<Todo> params) async {
    logger.info('Getting Todo list with params: $params');
    await Future.delayed(_delay);
    var items = TodoMockData.todos;

    // Apply limit if specified
    if (params.limit != null && params.limit! > 0) {
      items = items.take(params.limit!).toList();
    }

    logger.info('Successfully retrieved ${items.length} Todos');
    return items;
  }

  @override
  Stream<Todo> watch(QueryParams<Todo> params) {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      final item = TodoMockData.todos.query(params);
      return item;
    }).take(10); // Limit for demo
  }

  @override
  Stream<List<Todo>> watchList(ListQueryParams<Todo> params) {
    return Stream.periodic(const Duration(seconds: 2), (count) {
      var items = TodoMockData.todos;
      if (params.limit != null && params.limit! > 0) {
        items = items.take(params.limit!).toList();
      }
      return items;
    }).take(5); // Limit for demo
  }

  @override
  Future<Todo> create(Todo item) async {
    logger.info('Creating Todo: ${item.id}');
    await Future.delayed(_delay);
    // In a real implementation, you'd add to storage
    logger.info('Successfully created Todo: ${item.id}');
    return item;
  }

  @override
  Future<Todo> update(UpdateParams<Todo, TodoPatch> params) async {
    logger.info('Updating Todo with id: ${params.id}');
    await Future.delayed(_delay);
    final existing = TodoMockData.todos.firstWhere(
      (item) => item.id == params.id,
      orElse: () => throw notFoundFailure('Todo not found'),
    );
    // In a real implementation, you'd apply the update
    logger.info('Successfully updated Todo');
    return existing;
  }

  @override
  Future<void> delete(DeleteParams<Todo> params) async {
    logger.info('Deleting Todo with id: ${params.id}');
    await Future.delayed(_delay);
    final exists = TodoMockData.todos.any((item) => item.id == params.id);
    if (!exists) {
      throw notFoundFailure('Todo not found');
    }
    // In a real implementation, you'd remove from storage
    logger.info('Successfully deleted Todo');
  }
}
