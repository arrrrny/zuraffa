// Generated by zfa - Refactored modular version

class GeneratorConfig {
  final String name;
  final List<String> methods;
  final String? repo; // Changed from repos to single repo
  final String? service; // New: service to inject for custom UseCases
  final List<String> usecases; // New: for orchestrator pattern
  final List<String> variants; // New: for polymorphic pattern
  final String? domain; // New: required for custom UseCases
  final String? repoMethod; // New: repository method name
  final String? serviceMethod; // New: service method name
  final bool appendToExisting; // New: append to existing files
  final bool generateRepository;
  final String useCaseType;
  final String? paramsType;
  final String? returnsType;
  final String idField;
  final String idType;
  final bool generateVpc;
  final bool generateView;
  final bool generatePresenter;
  final bool generateController;
  final bool generateObserver;
  final bool generateData;
  final bool generateDataSource;
  final bool generateLocal;
  final bool generateState;
  final bool generateInit;
  final String queryField;
  final String queryFieldType;
  final bool useZorphy;
  final bool generateTest;
  final bool enableCache;
  final String cachePolicy;
  final String? cacheStorage;
  final int? ttlMinutes;
  final bool generateMock;
  final bool generateMockDataOnly;
  final bool useMockInDi;
  final bool generateDi;
  final String diFramework;
  final bool generateRoute;
  final bool generateGql;
  final String? gqlReturns;
  final String? gqlType;
  final String? gqlInputType;
  final String? gqlInputName;
  final String? gqlName;

  GeneratorConfig({
    required this.name,
    this.methods = const [],
    this.repo,
    this.service,
    this.usecases = const [],
    this.variants = const [],
    this.domain,
    this.repoMethod,
    this.serviceMethod,
    this.appendToExisting = false,
    this.generateRepository = false,
    this.useCaseType = 'usecase',
    this.paramsType,
    this.returnsType,
    this.idField = 'id',
    this.idType = 'String',
    this.generateVpc = false,
    this.generateView = false,
    this.generatePresenter = false,
    this.generateController = false,
    this.generateObserver = false,
    this.generateData = false,
    this.generateDataSource = false,
    this.generateLocal = false,
    this.generateState = false,
    this.generateInit = false,
    this.queryField = 'id',
    String? queryFieldType,
    this.useZorphy = false,
    this.generateTest = false,
    this.enableCache = false,
    this.cachePolicy = 'daily',
    this.cacheStorage,
    this.ttlMinutes,
    this.generateMock = false,
    this.generateMockDataOnly = false,
    this.useMockInDi = false,
    this.generateDi = false,
    this.diFramework = 'get_it',
    this.generateRoute = false,
    this.generateGql = false,
    this.gqlReturns,
    this.gqlType,
    this.gqlInputType,
    this.gqlInputName,
    this.gqlName,
  }) : queryFieldType = queryFieldType ?? idType;

  factory GeneratorConfig.fromJson(Map<String, dynamic> json, String name) {
    return GeneratorConfig(
      name: json['name'] ?? name,
      methods: (json['methods'] as List<dynamic>?)?.cast<String>() ?? [],
      repo: json['repo'],
      service: json['service'],
      usecases: (json['usecases'] as List<dynamic>?)?.cast<String>() ?? [],
      variants: (json['variants'] as List<dynamic>?)?.cast<String>() ?? [],
      domain: json['domain'],
      repoMethod: json['repo_method'] ?? json['method'],
      serviceMethod: json['service_method'] ?? json['method'],
      appendToExisting:
          json['append'] == true || json['append_to_existing'] == true,
      generateRepository: json['repository'] == true,
      useCaseType: json['type'] ?? 'usecase',
      paramsType: json['params'],
      returnsType: json['returns'],
      idField: json['id_field'] ?? 'id',
      idType: json['id_type'] ?? json['id_field_type'] ?? 'String',
      generateVpc: json['vpc'] == true,
      generateView: json['view'] == true,
      generatePresenter: json['presenter'] == true,
      generateController: json['controller'] == true,
      generateObserver: json['observer'] == true,
      generateData: json['data'] == true,
      generateDataSource: json['datasource'] == true,
      generateLocal: json['local'] == true,
      generateState: json['state'] == true,
      generateInit: json['init'] == true,
      queryField: json['query_field'] ?? 'id',
      queryFieldType: json['query_field_type'],
      useZorphy: json['zorphy'] == true || json['useZorphy'] == true,
      generateTest: json['test'] == true,
      enableCache: json['cache'] == true || json['enable_cache'] == true,
      cachePolicy: json['cache_policy'] ?? 'daily',
      cacheStorage: json['cache_storage'],
      ttlMinutes: json['ttl'] != null
          ? int.tryParse(json['ttl'].toString())
          : null,
      generateMock: json['mock'] == true || json['generate_mock'] == true,
      generateMockDataOnly:
          json['mock_data_only'] == true ||
          json['generate_mock_data_only'] == true,
      useMockInDi: json['use_mock'] == true || json['use_mock_in_di'] == true,
      generateDi: json['di'] == true || json['generate_di'] == true,
      diFramework: json['di_framework'] ?? 'get_it',
      generateRoute: json['route'] == true || json['generate_route'] == true,
      generateGql: json['gql'] == true || json['generate_gql'] == true,
      gqlReturns: json['gql_returns'],
      gqlType: json['gql_type'],
      gqlInputType: json['gql_input_type'],
      gqlInputName: json['gql_input_name'],
      gqlName: json['gql_name'],
    );
  }

  bool get isEntityBased => methods.isNotEmpty;

  bool get isCustomUseCase => methods.isEmpty;

  bool get isOrchestrator => usecases.isNotEmpty;

  bool get isPolymorphic => variants.isNotEmpty;

  String get effectiveDomain => domain ?? nameSnake;

  // Get repository method name (default: UseCase name in camelCase)
  String getRepoMethodName([String? variantPrefix]) {
    if (repoMethod != null) return repoMethod!;

    // For polymorphic with variant prefix
    if (variantPrefix != null) {
      return _pascalToCamel('$variantPrefix$name');
    }

    // Default: UseCase name in camelCase, strip "UseCase" suffix
    final methodName = name.endsWith('UseCase')
        ? name.substring(0, name.length - 7)
        : name;
    return _pascalToCamel(methodName);
  }

  // Get service method name (default: UseCase name in camelCase)
  String getServiceMethodName([String? variantPrefix]) {
    if (serviceMethod != null) return serviceMethod!;

    // For polymorphic with variant prefix
    if (variantPrefix != null) {
      return _pascalToCamel('$variantPrefix$name');
    }

    // Default: UseCase name in camelCase, strip "UseCase" suffix
    final methodName = name.endsWith('UseCase')
        ? name.substring(0, name.length - 7)
        : name;
    return _pascalToCamel(methodName);
  }

  // Check if using repository or service
  bool get hasRepo => repo != null;
  bool get hasService => service != null;

  // Backward compatibility helpers
  List<String> get repos => repo != null ? [repo!] : [];

  List<String> get effectiveRepos {
    if (repo != null) {
      // Ensure repo has Repository suffix
      final repoName = repo!.endsWith('Repository')
          ? repo!
          : '${repo!}Repository';
      return [repoName];
    }
    if (isEntityBased) return ['${name}Repository'];
    return [];
  }

  // Get effective service name with Service suffix
  String? get effectiveService {
    if (service == null) return null;
    return service!.endsWith('Service') ? service! : '${service!}Service';
  }

  // Get service snake case name (without Service suffix)
  String? get serviceSnake {
    if (service == null) return null;
    final baseName = service!.endsWith('Service')
        ? service!.substring(0, service!.length - 7)
        : service!;
    return _camelToSnake(baseName);
  }

  // Get effective provider name with Provider suffix
  String? get effectiveProvider {
    if (service == null) return null;
    final baseName = service!.endsWith('Service')
        ? service!.substring(0, service!.length - 7)
        : service!;
    // Provider name format: {ServiceName}Provider (e.g., EmailProvider, SmtpEmailProvider)
    // For now, use the simple format. Users can extend with custom providers manually.
    return '${baseName}Provider';
  }

  // Get provider snake case name (without Provider suffix)
  String? get providerSnake {
    if (service == null) return null;
    final baseName = service!.endsWith('Service')
        ? service!.substring(0, service!.length - 7)
        : service!;
    return _camelToSnake(baseName);
  }

  String get nameSnake => _camelToSnake(name);

  String get nameCamel => _pascalToCamel(name);

  String _camelToSnake(String input) {
    if (input.isEmpty) return '';
    final buffer = StringBuffer();
    for (var i = 0; i < input.length; i++) {
      final char = input[i];
      if (i > 0 && char.toUpperCase() == char && char != '_') {
        buffer.write('_');
      }
      buffer.write(char.toLowerCase());
    }
    return buffer.toString();
  }

  String _pascalToCamel(String input) {
    if (input.isEmpty) return '';
    return input[0].toLowerCase() + input.substring(1);
  }
}
