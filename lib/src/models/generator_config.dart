// Generated by zfa - Refactored modular version

class GeneratorConfig {
  final String name;
  final List<String> methods;
  final List<String> repos;
  final bool generateRepository;
  final String useCaseType;
  final String? paramsType;
  final String? returnsType;
  final String idField;
  final String idType;
  final bool generateVpc;
  final bool generateView;
  final bool generatePresenter;
  final bool generateController;
  final bool generateObserver;
  final bool generateData;
  final bool generateDataSource;
  final bool generateState;
  final bool generateInit;
  final String queryField;
  final String queryFieldType;
  final bool useMorphy;
  final String? subdirectory;

  GeneratorConfig({
    required this.name,
    this.methods = const [],
    this.repos = const [],
    this.generateRepository = false,
    this.useCaseType = 'usecase',
    this.paramsType,
    this.returnsType,
    this.idField = 'id',
    this.idType = 'String',
    this.generateVpc = false,
    this.generateView = false,
    this.generatePresenter = false,
    this.generateController = false,
    this.generateObserver = false,
    this.generateData = false,
    this.generateDataSource = false,
    this.generateState = false,
    this.generateInit = false,
    this.queryField = 'id',
    String? queryFieldType,
    this.useMorphy = false,
    this.subdirectory,
  }) : queryFieldType = queryFieldType ?? idType;

  factory GeneratorConfig.fromJson(Map<String, dynamic> json, String name) {
    return GeneratorConfig(
      name: json['name'] ?? name,
      methods: (json['methods'] as List<dynamic>?)?.cast<String>() ?? [],
      repos: (json['repos'] as List<dynamic>?)?.cast<String>() ?? [],
      generateRepository: json['repository'] == true,
      useCaseType: json['type'] ?? 'usecase',
      paramsType: json['params'],
      returnsType: json['returns'],
      idField: json['id_field'] ?? 'id',
      idType: json['id_type'] ?? json['id_field_type'] ?? 'String',
      generateVpc: json['vpc'] == true,
      generateView: json['view'] == true,
      generatePresenter: json['presenter'] == true,
      generateController: json['controller'] == true,
      generateObserver: json['observer'] == true,
      generateData: json['data'] == true,
      generateDataSource: json['datasource'] == true,
      generateState: json['state'] == true,
      generateInit: json['init'] == true,
      queryField: json['query_field'] ?? 'id',
      queryFieldType: json['query_field_type'],
      useMorphy: json['morphy'] == true || json['useMorphy'] == true,
      subdirectory: json['subdirectory'],
    );
  }

  bool get isEntityBased => methods.isNotEmpty;

  bool get isCustomUseCase =>
      methods.isEmpty && (repos.isNotEmpty || paramsType != null);

  List<String> get effectiveRepos {
    if (repos.isNotEmpty) return repos;
    if (isEntityBased) return ['${name}Repository'];
    return [];
  }

  String get nameSnake => _camelToSnake(name);

  String get nameCamel => _pascalToCamel(name);

  String _camelToSnake(String input) {
    if (input.isEmpty) return '';
    final buffer = StringBuffer();
    for (var i = 0; i < input.length; i++) {
      final char = input[i];
      if (i > 0 && char.toUpperCase() == char && char != '_') {
        buffer.write('_');
      }
      buffer.write(char.toLowerCase());
    }
    return buffer.toString();
  }

  String _pascalToCamel(String input) {
    if (input.isEmpty) return '';
    return input[0].toLowerCase() + input.substring(1);
  }
}
