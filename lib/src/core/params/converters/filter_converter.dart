import 'package:zorphy_annotation/zorphy_annotation.dart';

/// Converter for [Filter] type.
///
/// Provides static methods for serializing and deserializing Zorphy Filter objects.
///
/// The converter works with [Filter<dynamic>] to avoid generic type constraints
/// that json_serializable cannot handle directly.
///
/// ## Serialization
/// Filters are serialized using their built-in `toJson()` method, which is
/// automatically generated by the Zorphy code generator.
///
/// ## Deserialization
/// Deserialization is **limited** and requires manual creation of [Field] objects.
/// The converter can reconstruct simple comparison filters and logical operators,
/// but complex filters may need custom handling.
///
/// For full deserialization support, consider:
/// - Using a custom Field registry
/// - Implementing entity-specific deserializers
/// - Storing filters in a format that preserves field type information
///
/// ## Example
/// ```dart
/// // Serialization
/// final filter = Filter.eq(User.name, 'John');
/// final json = FilterConverter.toJson(filter);
/// // json: {'name': 'John'}
///
/// // Deserialization (requires manual Field creation)
/// final userField = Field<User, String>('name', (u) => u.name);
/// final decoded = FilterConverter.fromJson({'name': 'John'}, userField);
/// // decoded: Filter.eq(userField, 'John')
/// ```
class FilterConverter {
  FilterConverter._();

  /// Serializes a [Filter] to JSON.
  ///
  /// Uses Filter's built-in `toJson` method, which is provided by
  /// zorphy code generation.
  ///
  /// Throws [ArgumentError] if the filter does not support JSON serialization.
  static Map<String, dynamic>? toJson(Filter<dynamic>? filter) {
    if (filter == null) return null;
    try {
      return filter.toJson();
    } catch (e) {
      throw ArgumentError(
        'Failed to serialize Filter to JSON: $e\n'
        'Ensure the Filter is a valid Zorphy-generated filter.',
      );
    }
  }

  /// Deserializes a [Filter] from JSON.
  ///
  /// This method has **limited support** and requires providing the entity's
  /// [Field] objects for proper deserialization.
  ///
  /// For simple filters with known fields, you can provide a map of field names
  /// to [Field] objects:
  ///
  /// ```dart
  /// final userField = Field<User, String>('name', (u) => u.name);
  /// final ageField = Field<User, int>('age', (u) => u.age);
  ///
  /// final filter = FilterConverter.fromJson(
  ///   {'name': 'John', 'age': {'gt': 18}},
  ///   {'name': userField, 'age': ageField},
  /// );
  /// ```
  ///
  /// If no fields are provided, the deserialization will attempt to create
  /// generic [Field] objects, but these won't have `getValue` functions for
  /// matching operations.
  ///
  /// Throws [ArgumentError] if deserialization fails or the filter structure
  /// is unsupported.
  static Filter<dynamic>? fromJson(
    Map<String, dynamic>? json, [
    Map<String, Field<dynamic, dynamic>>? fields,
  ]) {
    if (json == null) return null;
    try {
      return _deserializeFilter(json, fields);
    } catch (e) {
      throw ArgumentError(
        'Failed to deserialize Filter from JSON: $json\n'
        'Error: $e\n'
        'Provide a map of Field objects for full deserialization support.',
      );
    }
  }

  /// Helper method to deserialize a Filter from JSON.
  ///
  /// Handles the reconstruction of Zorphy Filter types based on their
  /// JSON structure.
  ///
  /// Supported structures:
  /// - `{'field': value}` → Eq filter
  /// - `{'field': {'neq': value}}` → Neq filter
  /// - `{'field': {'gt': value}}` → Gt filter
  /// - `{'field': {'gte': value}}` → Gte filter
  /// - `{'field': {'lt': value}}` → Lt filter
  /// - `{'field': {'lte': value}}` → Lte filter
  /// - `{'field': {'contains': value}}` → Contains filter
  /// - `{'field': {'in': value}}` → InList filter
  /// - `{'and': [...]}` → And filter
  /// - `{'or': [...]}` → Or filter
  /// - `{}` → AlwaysMatch filter
  static Filter<dynamic> _deserializeFilter(
    Map<String, dynamic> json, [
    Map<String, Field<dynamic, dynamic>>? fields,
  ]) {
    // Handle empty filter
    if (json.isEmpty) {
      return Filter.always();
    }

    // Handle logical operators - use And/Or constructors
    if (json.containsKey('and')) {
      final filters = json['and'] as List<dynamic>?;
      if (filters == null || filters.isEmpty) {
        throw ArgumentError('And filter requires "and" array');
      }
      final deserializedFilters = <Filter<dynamic>>[];
      for (final f in filters.cast<Map<String, dynamic>>()) {
        deserializedFilters.add(_deserializeFilter(f, fields));
      }
      return And(deserializedFilters);
    }

    if (json.containsKey('or')) {
      final filters = json['or'] as List<dynamic>?;
      if (filters == null || filters.isEmpty) {
        throw ArgumentError('Or filter requires "or" array');
      }
      final deserializedFilters = <Filter<dynamic>>[];
      for (final f in filters.cast<Map<String, dynamic>>()) {
        deserializedFilters.add(_deserializeFilter(f, fields));
      }
      return Or(deserializedFilters);
    }

    // Handle field-based filters - use individual filter class constructors
    if (json.length == 1) {
      final entry = json.entries.first;
      final fieldName = entry.key;
      final value = entry.value;

      // Get or create the field
      final field = fields?[fieldName] ?? _createField(fieldName);

      // Check if value is a map with operator
      if (value is Map<String, dynamic>) {
        if (value.containsKey('neq')) {
          return Neq(field, value['neq']);
        } else if (value.containsKey('gt')) {
          return Gt(field, value['gt']);
        } else if (value.containsKey('gte')) {
          return Gte(field, value['gte']);
        } else if (value.containsKey('lt')) {
          return Lt(field, value['lt']);
        } else if (value.containsKey('lte')) {
          return Lte(field, value['lte']);
        } else if (value.containsKey('contains')) {
          return Contains(field, value['contains']);
        } else if (value.containsKey('in')) {
          final inListValue = value['in'];
          if (inListValue is List) {
            return InList(field, inListValue);
          }
          throw ArgumentError('"in" filter value must be a list');
        }
      }

      // Default to Eq filter
      return Eq(field, value);
    }

    throw ArgumentError(
      'Invalid filter structure: $json\n'
      'Expected a single field filter, and/or operator, or empty filter.',
    );
  }

  /// Creates a generic [Field] object for a given field name.
  ///
  /// This is a fallback when no field registry is provided. The created
  /// Field won't have a `getValue` function, so matching operations won't work.
  static Field<dynamic, dynamic> _createField(String fieldName) {
    return Field<dynamic, dynamic>(fieldName, null);
  }
}
