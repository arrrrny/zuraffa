import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';
import '../utils/string_utils.dart';

/// Generates service interface files for custom UseCases.
///
/// Services are an alternative to repositories for custom UseCases.
/// Use --service instead of --repo when you want to inject a service.
class ServiceGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;

  ServiceGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  });

  /// Generates a service interface file for a custom UseCase.
  Future<GeneratedFile> generate() async {
    final serviceName = config.effectiveService!;
    final serviceSnake = config.serviceSnake!;
    final fileName = '${serviceSnake}_service.dart';
    final filePath = path.join(outputDir, 'domain', 'services', fileName);

    final paramsType = config.paramsType ?? 'NoParams';
    final returnsType = config.returnsType ?? 'void';
    final methodName = config.getServiceMethodName();

    // Determine return type based on usecase type
    String returnSignature;
    switch (config.useCaseType) {
      case 'stream':
        returnSignature = 'Stream<$returnsType>';
        break;
      case 'completable':
        returnSignature = 'Future<void>';
        break;
      case 'sync':
        returnSignature = returnsType;
        break;
      default: // usecase, background
        returnSignature = 'Future<$returnsType>';
    }

    // Build method signature
    final methodSignature = paramsType == 'NoParams'
        ? '  $returnSignature $methodName();'
        : '  $returnSignature $methodName($paramsType params);';

    // Build imports
    final imports = <String>[];
    imports.add("import 'package:zuraffa/zuraffa.dart';");

    // Auto-import potential entity types from params and returns
    final entityImports = _getPotentialEntityImports([paramsType, returnsType]);
    for (final entityImport in entityImports) {
      final entitySnake = StringUtils.camelToSnake(entityImport);
      final entityPath = '../entities/$entitySnake/$entitySnake.dart';
      imports.add("import '$entityPath';");
    }

    final cliCommand =
        '// zfa generate ${config.name} --service=${config.service} --domain=${config.effectiveDomain} --params=$paramsType --returns=$returnsType${config.useCaseType != 'usecase' ? ' --type=${config.useCaseType}' : ''}${config.serviceMethod != null ? ' --service-method=${config.serviceMethod}' : ''}';

    final content =
        '''
// Generated by zfa
$cliCommand

${imports.join('\n')}

/// Service interface for ${config.name} UseCase.
///
/// Implement this interface in your data/infrastructure layer.
abstract class $serviceName {
$methodSignature
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'service',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  /// Extract potential entity types from type strings for auto-imports.
  List<String> _getPotentialEntityImports(List<String> types) {
    final entities = <String>[];
    final primitives = {
      'void',
      'String',
      'int',
      'double',
      'bool',
      'dynamic',
      'Object',
      'NoParams',
      'Map',
      'Set',
    };

    for (final type in types) {
      // Extract base types from generic wrappers like List<X>, Stream<X>, etc.
      final baseTypes = _extractBaseTypes(type);
      for (final baseType in baseTypes) {
        if (!primitives.contains(baseType) &&
            !baseType.startsWith('Map<') &&
            !baseType.startsWith('Set<')) {
          entities.add(baseType);
        }
      }
    }

    return entities.toSet().toList();
  }

  /// Extract base types from complex type strings.
  List<String> _extractBaseTypes(String type) {
    final results = <String>[];

    // Handle List<X>, Stream<X>, Future<X>, etc.
    final genericMatch = RegExp(r'(\w+)<(.+)>').firstMatch(type);
    if (genericMatch != null) {
      final innerType = genericMatch.group(2)!;
      // Recursively extract from inner types
      results.addAll(_extractBaseTypes(innerType));
    } else {
      // Simple type
      if (type.isNotEmpty && type != 'void') {
        results.add(type);
      }
    }

    return results;
  }
}
