import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';

class DataLayerGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;

  DataLayerGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  });

  Future<GeneratedFile> generateDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;

    // Always generate remote datasource (the actual implementation)
    await _generateRemoteDataSource();

    // If caching is enabled, also generate local datasource
    if (config.enableCache) {
      await _generateLocalDataSource();
    }

    // Generate abstract datasource (always)
    final dataSourceName = '${entityName}DataSource';
    final fileName = '${entitySnake}_data_source.dart';
    String relativePath = '../../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];

    if (config.generateInit) {
      methods.add('  Stream<bool> get isInitialized;');
      methods.add('  Future<void> initialize(InitializationParams params);');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('  Future<$entityName> get();');
          } else {
            methods.add(
                '  Future<$entityName> get(${config.queryFieldType} ${config.queryField});');
          }
          break;
        case 'getList':
          methods.add(
              '  Future<List<$entityName>> getList(ListQueryParams params);');
          break;
        case 'create':
          methods
              .add('  Future<$entityName> create($entityName $entityCamel);');
          break;
        case 'update':
          methods.add(
              '  Future<${config.name}> update(UpdateParams<${config.useMorphy ? "${config.name}Patch" : "Partial<${config.name}>"}> params);');
          break;
        case 'delete':
          methods
              .add('  Future<void> delete(DeleteParams<$entityName> params);');
          break;
        case 'watch':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('  Stream<$entityName> watch();');
          } else {
            methods.add(
                '  Stream<$entityName> watch(${config.queryFieldType} ${config.queryField});');
          }
          break;
        case 'watchList':
          methods.add(
              '  Stream<List<$entityName>> watchList(ListQueryParams params);');
          break;
      }
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data

import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';

abstract class $dataSourceName with Loggable, FailureHandler {
${methods.join('\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateRemoteDataSource() async {
    return _generateRemoteDataSource();
  }

  Future<GeneratedFile> generateLocalDataSource() async {
    return _generateLocalDataSource();
  }

  Future<GeneratedFile> _generateRemoteDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final dataSourceName = '${entityName}RemoteDataSource';
    final fileName = '${entitySnake}_remote_data_source.dart';
    String relativePath = '../../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];

    if (config.generateInit) {
      methods.add('''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing $dataSourceName');
    // TODO: Initialize remote connection, auth, etc.
    logger.info('$dataSourceName initialized');
  }''');

      methods.add('''
  @override
  Stream<bool> get isInitialized => Stream.value(true);''');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('''
  @override
  Future<$entityName> get() async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote get');
  }''');
          } else {
            methods.add('''
  @override
  Future<$entityName> get(${config.queryFieldType} ${config.queryField}) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote get');
  }''');
          }
          break;
        case 'getList':
          methods.add('''
  @override
  Future<List<$entityName>> getList(ListQueryParams params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote getList');
  }''');
          break;
        case 'create':
          methods.add('''
  Future<$entityName> create($entityName $entityCamel) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote create');
  }''');
          break;
        case 'update':
          methods.add('''
  Future<${config.name}> update(UpdateParams<${config.useMorphy ? "${config.name}Patch" : "Partial<${config.name}>"}> params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote update');
  }''');
          break;
        case 'delete':
          methods.add('''
  Future<void> delete(DeleteParams<$entityName> params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote delete');
  }''');
          break;
        case 'watch':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('''
  Stream<$entityName> watch() {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    throw UnimplementedError('Implement remote watch');
  }''');
          } else {
            methods.add('''
  Stream<$entityName> watch(${config.queryFieldType} ${config.queryField}) {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    throw UnimplementedError('Implement remote watch');
  }''');
          }
          break;
        case 'watchList':
          methods.add('''
  Stream<List<$entityName>> watchList(ListQueryParams params) {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    throw UnimplementedError('Implement remote watchList');
  }''');
          break;
      }
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache

import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';
import '${entitySnake}_data_source.dart';

/// Remote data source for $entityName.
///
/// Fetches data from external API/service.
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  // TODO: Add HTTP client or API service dependency
  // final ApiClient _apiClient;
  // $dataSourceName(this._apiClient);

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'remote_datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> _generateLocalDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final dataSourceName = '${entityName}LocalDataSource';
    final fileName = '${entitySnake}_local_data_source.dart';
    String relativePath = '../../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];
    final storageComment = config.cacheStorage != null
        ? '// Using ${config.cacheStorage} for local storage'
        : '// TODO: Choose storage (Hive, SQLite, SharedPreferences, etc.)';

    if (config.generateInit) {
      methods.add('''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing $dataSourceName');
    // TODO: Initialize local storage, open database, etc.
    logger.info('$dataSourceName initialized');
  }''');

      methods.add('''
  @override
  Stream<bool> get isInitialized => Stream.value(true);''');
    }

    // Generate Hive implementation if specified
    if (config.cacheStorage == 'hive') {
      if (config.idField == 'null') {
        // For singleton entities, use entity name as key
        methods.add('''
  Future<$entityName> save($entityName $entityCamel) async {
    await _box.put('$entitySnake', $entityCamel);
    return $entityCamel;
  }''');
      } else {
        methods.add('''
  Future<$entityName> save($entityName $entityCamel) async {
    await _box.put($entityCamel.${config.idField}, $entityCamel);
    return $entityCamel;
  }''');

        methods.add('''
  Future<void> saveAll(List<$entityName> items) async {
    final map = {for (var item in items) item.${config.idField}: item};
    await _box.putAll(map);
  }''');
      }

      methods.add('''
  Future<void> clear() async {
    await _box.clear();
  }''');

      for (final method in config.methods) {
        switch (method) {
          case 'get':
            if (config.idField == 'null') {
              methods.add('''
  @override
  Future<$entityName> get() async {
    final item = _box.get('$entitySnake');
    if (item == null) {
      throw NotFoundFailure('$entityName not found in cache');
    }
    return item;
  }''');
            } else {
              methods.add('''
  @override
  Future<$entityName> get(${config.queryFieldType} ${config.queryField}) async {
    final item = _box.get(${config.queryField});
    if (item == null) {
      throw NotFoundFailure('$entityName not found in cache');
    }
    return item;
  }''');
            }
            break;
          case 'getList':
            methods.add('''
  @override
  Future<List<$entityName>> getList(ListQueryParams params) async {
    return _box.values.toList();
  }''');
            break;
          case 'update':
            methods.add('''
  Future<${config.name}> update(UpdateParams<${config.useMorphy ? "${config.name}Patch" : "Partial<${config.name}>"}> params) async {
    final existing = _box.get(params.${config.idField});
    if (existing == null) {
      throw NotFoundFailure('$entityName not found in cache');
    }
    // TODO: Apply partial update to existing entity
    await _box.put(params.${config.idField}, existing);
    return existing;
  }''');
            break;
          case 'delete':
            methods.add('''
  Future<void> delete(DeleteParams<$entityName> params) async {
    await _box.delete(params.${config.idField});
  }''');
            break;
        }
      }

      final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache --cache-storage=hive

import 'package:hive_ce_flutter/hive_ce_flutter.dart';
import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';
import '${entitySnake}_data_source.dart';

/// Local data source for $entityName using Hive.
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  final Box<$entityName> _box;

  $dataSourceName(this._box);

${methods.join('\n\n')}
}
''';

      return FileUtils.writeFile(
        filePath,
        content,
        'local_datasource',
        force: force,
        dryRun: dryRun,
        verbose: verbose,
      );
    }

    // Default implementation with TODOs
    methods.add('''
  Future<$entityName> save($entityName $entityCamel) async {
    // TODO: Implement local storage write
    throw UnimplementedError('Implement local save');
  }''');

    if (config.idField != 'null') {
      methods.add('''
  Future<void> saveAll(List<$entityName> items) async {
    // TODO: Implement bulk save to local storage
    throw UnimplementedError('Implement local saveAll');
  }''');
    }

    methods.add('''
  Future<void> clear() async {
    // TODO: Implement clear all cached data
    throw UnimplementedError('Implement local clear');
  }''');

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null') {
            methods.add('''
  Future<$entityName> get() async {
    // TODO: Implement local storage read
    throw UnimplementedError('Implement local get');
  }''');
          } else {
            methods.add('''
  Future<$entityName> get(${config.queryFieldType} ${config.queryField}) async {
    // TODO: Implement local storage read
    throw UnimplementedError('Implement local get');
  }''');
          }
          break;
        case 'getList':
          methods.add('''
  Future<List<$entityName>> getList(ListQueryParams params) async {
    // TODO: Implement local storage read
    throw UnimplementedError('Implement local getList');
  }''');
          break;
        case 'update':
          methods.add('''
  Future<${config.name}> update(UpdateParams<${config.useMorphy ? "${config.name}Patch" : "Partial<${config.name}>"}> params) async {
    // TODO: Implement local storage update
    throw UnimplementedError('Implement local update');
  }''');
          break;
        case 'delete':
          methods.add('''
  Future<void> delete(DeleteParams<$entityName> params) async {
    // TODO: Implement local storage delete
    throw UnimplementedError('Implement local delete');
  }''');
          break;
      }
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache

import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';
import '${entitySnake}_data_source.dart';

/// Local data source for $entityName.
///
/// $storageComment
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  // TODO: Add storage dependency (Hive, SQLite, etc.)
  // final Box<$entityName> _box;
  // $dataSourceName(this._box);

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'local_datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateDataRepository() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final repoName = '${entityName}Repository';
    final dataRepoName = 'Data${entityName}Repository';

    // Use different datasource names based on caching
    final dataSourceName = '${entityName}DataSource';
    final localDataSourceName = '${entityName}LocalDataSource';

    final fileName = 'data_${entitySnake}_repository.dart';

    String relativePath = '../';
    final dataRepoPathParts = <String>[outputDir, 'data', 'repositories'];
    final dataRepoDirPath = path.joinAll(dataRepoPathParts);
    final filePath = path.join(dataRepoDirPath, fileName);

    final methods = <String>[];

    // Constructor parameters
    final constructorParams = config.enableCache
        ? '''  final $dataSourceName _remoteDataSource;
  final $localDataSourceName _localDataSource;
  final CachePolicy _cachePolicy;

  $dataRepoName(
    this._remoteDataSource,
    this._localDataSource,
    this._cachePolicy,
  );'''
        : '''  final $dataSourceName _dataSource;

  $dataRepoName(this._dataSource);''';

    if (config.generateInit) {
      if (config.enableCache) {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _remoteDataSource.isInitialized;''');

        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _remoteDataSource.initialize(params);
  }''');
      } else {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _dataSource.isInitialized;''');

        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _dataSource.initialize(params);
  }''');
      }
    }

    for (final method in config.methods) {
      if (config.enableCache) {
        // Generate cache-aware methods
        methods.add(_generateCachedMethod(method, entityName, entityCamel));
      } else {
        // Generate simple pass-through methods
        methods.add(_generateSimpleMethod(method, entityName, entityCamel));
      }
    }

    // Import statements
    final dataSourceImport = config.enableCache
        ? '''import '${relativePath}data_sources/$entitySnake/${entitySnake}_data_source.dart';
import '${relativePath}data_sources/$entitySnake/${entitySnake}_local_data_source.dart';'''
        : '''import '${relativePath}data_sources/$entitySnake/${entitySnake}_data_source.dart';''';

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data${config.enableCache ? ' --cache=${config.cachePolicy}' : ''}

import 'package:zuraffa/zuraffa.dart';
import '../../domain/entities/$entitySnake/$entitySnake.dart';
import '../../domain/repositories/${entitySnake}_repository.dart';
$dataSourceImport

class $dataRepoName with Loggable, FailureHandler implements $repoName {
$constructorParams

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'data_repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  String _generateSimpleMethod(
      String method, String entityName, String entityCamel) {
    switch (method) {
      case 'get':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Future<$entityName> get() {
    return _dataSource.get();
  }''';
        } else {
          return '''  @override
  Future<$entityName> get(${config.queryFieldType} ${config.queryField}) {
    return _dataSource.get(${config.queryField});
  }''';
        }
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams params) {
    return _dataSource.getList(params);
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) {
    return _dataSource.create($entityCamel);
  }''';
      case 'update':
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.useMorphy ? "${config.name}Patch" : "Partial<${config.name}>"}> params) {
    return _dataSource.update(params);
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<$entityName> params) {
    return _dataSource.delete(params);
  }''';
      case 'watch':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Stream<$entityName> watch() {
    return _dataSource.watch();
  }''';
        } else {
          return '''  @override
  Stream<$entityName> watch(${config.queryFieldType} ${config.queryField}) {
    return _dataSource.watch(${config.queryField});
  }''';
        }
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams params) {
    return _dataSource.watchList(params);
  }''';
      default:
        return '';
    }
  }

  String _generateCachedMethod(
      String method, String entityName, String entityCamel) {
    final baseCacheKey = '${config.nameSnake}_cache';

    switch (method) {
      case 'get':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Future<$entityName> get() async {
    // Check cache validity
    if (await _cachePolicy.isValid('$baseCacheKey')) {
      try {
        return await _localDataSource.get();
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.get();

    // Update cache
    await _localDataSource.save(data);
    await _cachePolicy.markFresh('$baseCacheKey');

    return data;
  }''';
        } else {
          return '''  @override
  Future<$entityName> get(${config.queryFieldType} ${config.queryField}) async {
    // Check cache validity
    if (await _cachePolicy.isValid('$baseCacheKey')) {
      try {
        return await _localDataSource.get(${config.queryField});
      } catch (e) {
        logger.severe('Cache miss for ${config.queryField}, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.get(${config.queryField});

    // Update cache
    await _localDataSource.save(data);
    await _cachePolicy.markFresh('$baseCacheKey');

    return data;
  }''';
        }
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams params) async {
    // Include params in cache key for granular caching
    final listCacheKey = '${baseCacheKey}_\${params.hashCode}';
    
    // Check cache validity
    if (await _cachePolicy.isValid(listCacheKey)) {
      try {
        return await _localDataSource.getList(params);
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.getList(params);

    // Update cache
    await _localDataSource.saveAll(data);
    await _cachePolicy.markFresh(listCacheKey);

    return data;
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) async {
    // Create on remote
    final created = await _remoteDataSource.create($entityCamel);

    // Update local cache
    await _localDataSource.save(created);

    return created;
  }''';
      case 'update':
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.useMorphy ? "${config.name}Patch" : "Partial<${config.name}>"}> params) async {
    // Update on remote
    final updated = await _remoteDataSource.update(params);

    // Update local cache
    await _localDataSource.update(params);

    return updated;
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<$entityName> params) async {
    // Delete from remote
    await _remoteDataSource.delete(params);

    // Delete from local cache
    await _localDataSource.delete(params);

    // Optionally invalidate cache
    await _cachePolicy.invalidate('$baseCacheKey');
  }''';
      case 'watch':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Stream<$entityName> watch() {
    // For streams, typically use remote source
    // You may want to seed with cached data first
    return _remoteDataSource.watch();
  }''';
        } else {
          return '''  @override
  Stream<$entityName> watch(${config.queryFieldType} ${config.queryField}) {
    // For streams, typically use remote source
    // You may want to seed with cached data first
    return _remoteDataSource.watch(${config.queryField});
  }''';
        }
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams params) {
    // For streams, typically use remote source
    // You may want to seed with cached data first
    return _remoteDataSource.watchList(params);
  }''';
      default:
        return '';
    }
  }
}
