import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';

class DataLayerGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;

  DataLayerGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  });

  Future<GeneratedFile> generateDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final dataSourceName = '${entityName}DataSource';
    final fileName = '${entitySnake}_data_source.dart';
    String relativePath = '../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      dataSourcePathParts.add(config.subdirectory!);
      relativePath += '../';
    }
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];

    if (config.generateInit) {
      methods.add('  Stream<bool> get isInitialized;');
      methods.add('  Future<void> initialize(InitializationParams params);');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          methods.add('  Future<$entityName> get(${config.idType} id);');
          break;
        case 'getList':
          methods.add('  Future<List<$entityName>> getList();');
          break;
        case 'create':
          methods
              .add('  Future<$entityName> create($entityName $entityCamel);');
          break;
        case 'update':
          methods
              .add('  Future<$entityName> update($entityName $entityCamel);');
          break;
        case 'delete':
          methods.add('  Future<void> delete(${config.idType} id);');
          break;
        case 'watch':
          methods.add('  Stream<$entityName> watch(${config.idType}? id);');
          break;
        case 'watchList':
          methods.add('  Stream<List<$entityName>> watchList();');
          break;
      }
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data

import 'package:zuraffa/zuraffa.dart';
import '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';

abstract class $dataSourceName {
${methods.join('\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateDataRepository() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final repoName = '${entityName}Repository';
    final dataRepoName = 'Data${entityName}Repository';
    final dataSourceName = '${entityName}DataSource';
    final fileName = 'data_${entitySnake}_repository.dart';
    final filePath = path.join(outputDir, 'data', 'repositories', fileName);

    final relativePath =
        config.subdirectory != null && config.subdirectory!.isNotEmpty
            ? '../'
            : '';

    final methods = <String>[];

    if (config.generateInit) {
      methods.add('''
  @override
  Stream<bool> get isInitialized => _dataSource.isInitialized;''');

      methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _dataSource.initialize(params);
  }''');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          methods.add('''
  @override
  Future<$entityName> get(${config.idType} id) {
    return _dataSource.get(id);
  }''');
          break;
        case 'getList':
          methods.add('''
  @override
  Future<List<$entityName>> getList() {
    return _dataSource.getList();
  }''');
          break;
        case 'create':
          methods.add('''
  @override
  Future<$entityName> create($entityName $entityCamel) {
    return _dataSource.create($entityCamel);
  }''');
          break;
        case 'update':
          methods.add('''
  @override
  Future<$entityName> update($entityName $entityCamel) {
    return _dataSource.update($entityCamel);
  }''');
          break;
        case 'delete':
          methods.add('''
  @override
  Future<void> delete(${config.idType} id) {
    return _dataSource.delete(id);
  }''');
          break;
        case 'watch':
          methods.add('''
  @override
  Stream<$entityName> watch(${config.idType}? id) {
    return _dataSource.watch(id);
  }''');
          break;
        case 'watchList':
          methods.add('''
  @override
  Stream<List<$entityName>> watchList() {
    return _dataSource.watchList();
  }''');
          break;
      }
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data

import 'package:zuraffa/zuraffa.dart';
import '$relativePath../../domain/entities/$entitySnake/$entitySnake.dart';
import '$relativePath../../domain/repositories/${entitySnake}_repository.dart';
import '$relativePath../data_sources/$entitySnake/${entitySnake}_data_source.dart';

class $dataRepoName with Loggable implements $repoName {
  final $dataSourceName _dataSource;

  $dataRepoName(this._dataSource);

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'data_repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }
}
