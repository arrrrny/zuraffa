import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';

class DataLayerGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;

  DataLayerGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  });

  Future<GeneratedFile> generateDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;

    // Always generate remote datasource (the actual implementation)
    await _generateRemoteDataSource();

    // If caching is enabled, also generate local datasource
    if (config.enableCache) {
      await _generateLocalDataSource();
    }

    // Generate abstract datasource (always)
    final dataSourceName = '${entityName}DataSource';
    final fileName = '${entitySnake}_data_source.dart';
    String relativePath = '../../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];

    if (config.generateInit) {
      methods.add('  Stream<bool> get isInitialized;');
      methods.add('  Future<void> initialize(InitializationParams params);');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('  Future<$entityName> get();');
          } else {
            methods.add(
              '  Future<$entityName> get(QueryParams<$entityName> params);',
            );
          }
          break;
        case 'getList':
          methods.add(
            '  Future<List<$entityName>> getList(ListQueryParams<$entityName> params);',
          );
          break;
        case 'create':
          methods.add(
            '  Future<$entityName> create($entityName $entityCamel);',
          );
          break;
        case 'update':
          final dataType = config.useZorphy
              ? '${config.name}Patch'
              : 'Partial<${config.name}>';
          methods.add(
            '  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params);',
          );
          break;
        case 'delete':
          methods.add(
            '  Future<void> delete(DeleteParams<${config.idType}> params);',
          );
          break;
        case 'watch':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('  Stream<$entityName> watch();');
          } else {
            methods.add(
              '  Stream<$entityName> watch(QueryParams<$entityName> params);',
            );
          }
          break;
        case 'watchList':
          methods.add(
            '  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params);',
          );
          break;
      }
    }

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data

import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';

abstract class $dataSourceName with Loggable, FailureHandler {
${methods.join('\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateRemoteDataSource() async {
    return _generateRemoteDataSource();
  }

  Future<GeneratedFile> generateLocalDataSource() async {
    return _generateLocalDataSource();
  }

  Future<GeneratedFile> _generateRemoteDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final dataSourceName = '${entityName}RemoteDataSource';
    final fileName = '${entitySnake}_remote_data_source.dart';
    String relativePath = '../../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];

    if (config.generateInit) {
      methods.add('''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing $dataSourceName');
    // TODO: Initialize remote connection, auth, etc.
    logger.info('$dataSourceName initialized');
  }''');

      methods.add('''
  @override
  Stream<bool> get isInitialized => Stream.value(true);''');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('''
  @override
  Future<$entityName> get() async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote get');
  }''');
          } else {
            methods.add('''
  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote get');
  }''');
          }
          break;
        case 'getList':
          methods.add('''
  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote getList');
  }''');
          break;
        case 'create':
          methods.add('''
  @override
  Future<$entityName> create($entityName $entityCamel) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote create');
  }''');
          break;
        case 'update':
          final dataType = config.useZorphy
              ? '${config.name}Patch'
              : 'Partial<${config.name}>';
          methods.add('''
  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote update');
  }''');
          break;
        case 'delete':
          methods.add('''
  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    // TODO: Implement remote API call
    throw UnimplementedError('Implement remote delete');
  }''');
          break;
        case 'watch':
          if (config.idField == 'null' || config.queryField == 'null') {
            methods.add('''
  @override
  Stream<$entityName> watch() {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    throw UnimplementedError('Implement remote watch');
  }''');
          } else {
            methods.add('''
  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    throw UnimplementedError('Implement remote watch');
  }''');
          }
          break;
        case 'watchList':
          methods.add('''
  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    throw UnimplementedError('Implement remote watchList');
  }''');
          break;
      }
    }

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache

import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';
import '${entitySnake}_data_source.dart';

/// Remote data source for $entityName.
///
/// Fetches data from external API/service.
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  // TODO: Add HTTP client or API service dependency
  // final ApiClient _apiClient;
  // $dataSourceName(this._apiClient);

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'remote_datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> _generateLocalDataSource() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final dataSourceName = '${entityName}LocalDataSource';
    final fileName = '${entitySnake}_local_data_source.dart';
    String relativePath = '../../../';

    final dataSourcePathParts = <String>[outputDir, 'data', 'data_sources'];
    dataSourcePathParts.add(entitySnake);
    final dataSourceDirPath = path.joinAll(dataSourcePathParts);
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];
    final storageComment = config.cacheStorage != null
        ? '// Using ${config.cacheStorage} for local storage'
        : '// TODO: Choose storage (Hive, SQLite, SharedPreferences, etc.)';

    if (config.generateInit) {
      methods.add('''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing $dataSourceName');
    // TODO: Initialize local storage, open database, etc.
    logger.info('$dataSourceName initialized');
  }''');

      methods.add('''
  @override
  Stream<bool> get isInitialized => Stream.value(true);''');
    }

    // Generate Hive implementation if specified
    if (config.cacheStorage == 'hive') {
      final hasListMethods = config.methods.any(
        (m) => m == 'getList' || m == 'watchList',
      );

      if (config.idField == 'null' || !hasListMethods) {
        // Single entity cache — use entity name as fixed key
        methods.add('''
  Future<$entityName> save($entityName $entityCamel) async {
    await _box.put('$entitySnake', $entityCamel);
    return $entityCamel;
  }''');
      } else {
        // Collection cache — key by entity id
        methods.add('''
  Future<$entityName> save($entityName $entityCamel) async {
    await _box.put($entityCamel.${config.idField}, $entityCamel);
    return $entityCamel;
  }''');

        methods.add('''
  Future<void> saveAll(List<$entityName> items) async {
    final map = {for (var item in items) item.${config.idField}: item};
    await _box.putAll(map);
  }''');
      }

      methods.add('''
  Future<void> clear() async {
    await _box.clear();
  }''');

      for (final method in config.methods) {
        switch (method) {
          case 'get':
            if (config.idField == 'null' || !hasListMethods) {
              methods.add('''
  @override
  Future<$entityName> get(${config.idField == 'null' ? '' : 'QueryParams<$entityName> params'}) async {
    final item = _box.get('$entitySnake');
    if (item == null) {
      throw notFoundFailure('$entityName not found in cache');
    }
    return item;
  }''');
            } else {
              methods.add('''
  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    return _box.values.query(params);
  }''');
            }
            break;
          case 'getList':
            methods.add('''
  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    return _box.values.filter(params.filter).orderBy(params.sort);
  }''');
            break;
          case 'create':
            if (hasListMethods) {
              methods.add('''
  @override
  Future<$entityName> create($entityName $entityCamel) async {
    await _box.put($entityCamel.${config.idField}, $entityCamel);
    return $entityCamel;
  }''');
            } else {
              methods.add('''
  @override
  Future<$entityName> create($entityName $entityCamel) async {
    await _box.put('$entitySnake', $entityCamel);
    return $entityCamel;
  }''');
            }
            break;
          case 'update':
            final dataType = config.useZorphy
                ? '${config.name}Patch'
                : 'Partial<${config.name}>';
            if (hasListMethods) {
              methods.add('''
  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    final existing = _box.values.firstWhere(
      (item) => item.${config.idField} == params.id,
      orElse: () => throw notFoundFailure('$entityName not found in cache'),
    );
    ${config.useZorphy ? '''
    final updated = params.data.applyTo(existing);
    await _box.put(updated.${config.idField}, updated);
    return updated;''' : '''
    // TODO: Apply Partial<$entityName> patch to existing entity
    await _box.put(existing.${config.idField}, existing);
    return existing;'''}
  }''');
            } else {
              methods.add('''
  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    final existing = _box.get('$entitySnake');
    if (existing == null) {
      throw notFoundFailure('$entityName not found in cache');
    }
    ${config.useZorphy ? '''
    final updated = params.data.applyTo(existing);
    await _box.put('$entitySnake', updated);
    return updated;''' : '''
    // TODO: Apply Partial<$entityName> patch to existing entity
    await _box.put('$entitySnake', existing);
    return existing;'''}
  }''');
            }
            break;
          case 'delete':
            if (hasListMethods) {
              methods.add('''
  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    final existing = _box.values.firstWhere(
      (item) => item.${config.idField} == params.id,
      orElse: () => throw notFoundFailure('$entityName not found in cache'),
    );
    await _box.delete(existing.${config.idField});
  }''');
            } else {
              methods.add('''
  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    await _box.delete('$entitySnake');
  }''');
            }
            break;
          case 'watch':
            if (config.idField == 'null' || !hasListMethods) {
              methods.add('''
  @override
  Stream<$entityName> watch(${config.idField == 'null' ? '' : 'QueryParams<$entityName> params'}) async* {
    final existing = _box.get('$entitySnake');
    if (existing != null) yield existing;

    yield* _box
        .watch(key: '$entitySnake')
        .where((event) => event.value != null)
        .map((event) => event.value as $entityName);
  }''');
            } else {
              methods.add('''
  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) async* {
    try {
      yield _box.values.query(params);
    } catch (_) {}

    yield* _box.watch().map((_) => _box.values.query(params));
  }''');
            }
            break;
          case 'watchList':
            methods.add('''
  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) async* {
    final existing = _box.values.filter(params.filter).orderBy(params.sort);
    yield existing;

    yield* _box.watch().map((_) => _box.values.filter(params.filter).orderBy(params.sort));
  }''');
            break;
        }
      }

      final content =
          '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache --cache-storage=hive

import 'package:hive_ce_flutter/hive_ce_flutter.dart';
import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';
import '${entitySnake}_data_source.dart';

/// Local data source for $entityName using Hive.
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  final Box<$entityName> _box;

  $dataSourceName(this._box);

${methods.join('\n\n')}
}
''';

      return FileUtils.writeFile(
        filePath,
        content,
        'local_datasource',
        force: force,
        dryRun: dryRun,
        verbose: verbose,
      );
    }

    // Default implementation with TODOs
    methods.add('''
  Future<$entityName> save($entityName $entityCamel) async {
    // TODO: Implement local storage write
    throw UnimplementedError('Implement local save');
  }''');

    if (config.idField != 'null') {
      methods.add('''
  Future<void> saveAll(List<$entityName> items) async {
    // TODO: Implement bulk save to local storage
    throw UnimplementedError('Implement local saveAll');
  }''');
    }

    methods.add('''
  Future<void> clear() async {
    // TODO: Implement clear all cached data
    throw UnimplementedError('Implement local clear');
  }''');

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null') {
            methods.add('''
  Future<$entityName> get() async {
    // TODO: Implement local storage read
    throw UnimplementedError('Implement local get');
  }''');
          } else {
            methods.add('''
  Future<$entityName> get(QueryParams<$entityName> params) async {
    // TODO: Implement local storage read
    throw UnimplementedError('Implement local get');
  }''');
          }
          break;
        case 'getList':
          methods.add('''
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    // TODO: Implement local storage read
    throw UnimplementedError('Implement local getList');
  }''');
          break;
        case 'update':
          final dataType = config.useZorphy
              ? '${config.name}Patch'
              : 'Partial<${config.name}>';
          methods.add('''
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    // TODO: Implement local storage update
    throw UnimplementedError('Implement local update');
  }''');
          break;
        case 'delete':
          methods.add('''
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    // TODO: Implement local storage delete
    throw UnimplementedError('Implement local delete');
  }''');
          break;
      }
    }

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache

import 'package:zuraffa/zuraffa.dart';
import '${relativePath}domain/entities/$entitySnake/$entitySnake.dart';
import '${entitySnake}_data_source.dart';

/// Local data source for $entityName.
///
/// $storageComment
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  // TODO: Add storage dependency (Hive, SQLite, etc.)
  // final Box<$entityName> _box;
  // $dataSourceName(this._box);

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'local_datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateDataRepository() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final repoName = '${entityName}Repository';
    final dataRepoName = 'Data${entityName}Repository';

    // Use different datasource names based on caching
    final dataSourceName = '${entityName}DataSource';
    final localDataSourceName = '${entityName}LocalDataSource';

    final fileName = 'data_${entitySnake}_repository.dart';

    String relativePath = '../';
    final dataRepoPathParts = <String>[outputDir, 'data', 'repositories'];
    final dataRepoDirPath = path.joinAll(dataRepoPathParts);
    final filePath = path.join(dataRepoDirPath, fileName);

    final methods = <String>[];

    // Constructor parameters
    final constructorParams = config.enableCache
        ? '''  final $dataSourceName _remoteDataSource;
  final $localDataSourceName _localDataSource;
  final CachePolicy _cachePolicy;

  $dataRepoName(
    this._remoteDataSource,
    this._localDataSource,
    this._cachePolicy,
  );'''
        : '''  final $dataSourceName _dataSource;

  $dataRepoName(this._dataSource);''';

    if (config.generateInit) {
      if (config.enableCache) {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _remoteDataSource.isInitialized;''');

        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _remoteDataSource.initialize(params);
  }''');
      } else {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _dataSource.isInitialized;''');

        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _dataSource.initialize(params);
  }''');
      }
    }

    for (final method in config.methods) {
      if (config.enableCache) {
        // Generate cache-aware methods
        methods.add(_generateCachedMethod(method, entityName, entityCamel));
      } else {
        // Generate simple pass-through methods
        methods.add(_generateSimpleMethod(method, entityName, entityCamel));
      }
    }

    // Import statements
    final dataSourceImport = config.enableCache
        ? '''import '${relativePath}data_sources/$entitySnake/${entitySnake}_data_source.dart';
import '${relativePath}data_sources/$entitySnake/${entitySnake}_local_data_source.dart';'''
        : '''import '${relativePath}data_sources/$entitySnake/${entitySnake}_data_source.dart';''';

    final hasWatchMethods = config.methods.any(
      (m) => m == 'watch' || m == 'watchList',
    );
    final asyncImport = config.enableCache && hasWatchMethods
        ? "import 'dart:async';\n\n"
        : '';

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data${config.enableCache ? ' --cache=${config.cachePolicy}' : ''}

${asyncImport}import 'package:zuraffa/zuraffa.dart';
import '../../domain/entities/$entitySnake/$entitySnake.dart';
import '../../domain/repositories/${entitySnake}_repository.dart';
$dataSourceImport

class $dataRepoName with Loggable, FailureHandler implements $repoName {
$constructorParams

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'data_repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  String _generateSimpleMethod(
    String method,
    String entityName,
    String entityCamel,
  ) {
    switch (method) {
      case 'get':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Future<$entityName> get() {
    return _dataSource.get();
  }''';
        } else {
          return '''  @override
  Future<$entityName> get(QueryParams<$entityName> params) {
    return _dataSource.get(params);
  }''';
        }
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) {
    return _dataSource.getList(params);
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) {
    return _dataSource.create($entityCamel);
  }''';
      case 'update':
        final dataType = config.useZorphy
            ? '${config.name}Patch'
            : 'Partial<${config.name}>';
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) {
    return _dataSource.update(params);
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<${config.idType}> params) {
    return _dataSource.delete(params);
  }''';
      case 'watch':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Stream<$entityName> watch() {
    return _dataSource.watch();
  }''';
        } else {
          return '''  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    return _dataSource.watch(params);
  }''';
        }
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    return _dataSource.watchList(params);
  }''';
      default:
        return '';
    }
  }

  String _generateCachedMethod(
    String method,
    String entityName,
    String entityCamel,
  ) {
    final baseCacheKey = '${config.nameSnake}_cache';

    switch (method) {
      case 'get':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Future<$entityName> get() async {
    // Check cache validity
    if (await _cachePolicy.isValid('$baseCacheKey')) {
      try {
        return await _localDataSource.get();
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.get();

    // Update cache
    await _localDataSource.save(data);
    await _cachePolicy.markFresh('$baseCacheKey');

    return data;
  }''';
        } else {
          return '''  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    // Check cache validity
    if (await _cachePolicy.isValid('$baseCacheKey')) {
      try {
        return await _localDataSource.get(params);
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.get(params);

    // Update cache
    await _localDataSource.save(data);
    await _cachePolicy.markFresh('$baseCacheKey');

    return data;
  }''';
        }
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    // Include params in cache key for granular caching
    final listCacheKey = '${baseCacheKey}_\${params.hashCode}';

    // Check cache validity
    if (await _cachePolicy.isValid(listCacheKey)) {
      try {
        return await _localDataSource.getList(params);
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.getList(params);

    // Update cache
    await _localDataSource.saveAll(data);
    await _cachePolicy.markFresh(listCacheKey);

    return data;
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) async {
    // Create on remote
    final created = await _remoteDataSource.create($entityCamel);

    // Update local cache
    await _localDataSource.save(created);

    // Invalidate list cache since a new item was added
    await _cachePolicy.invalidate('$baseCacheKey');

    return created;
  }''';
      case 'update':
        final dataType = config.useZorphy
            ? '${config.name}Patch'
            : 'Partial<${config.name}>';
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    // Update on remote
    final updated = await _remoteDataSource.update(params);

    // Update local cache
    await _localDataSource.update(params);

    // Invalidate cache since data was modified
    await _cachePolicy.invalidate('$baseCacheKey');

    return updated;
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    // Delete from remote
    await _remoteDataSource.delete(params);

    // Delete from local cache
    await _localDataSource.delete(params);

    // Invalidate all cache since data was removed
    await _cachePolicy.invalidate('$baseCacheKey');
  }''';
      case 'watch':
        if (config.idField == 'null' || config.queryField == 'null') {
          return '''  @override
  Stream<$entityName> watch() {
    // Local drives the stream, remote syncs in background
    late final StreamController<$entityName> controller;
    StreamSubscription<$entityName>? localSub;
    StreamSubscription<$entityName>? remoteSub;

    controller = StreamController<$entityName>(
      onListen: () {
        localSub = _localDataSource.watch().listen(
          controller.add,
          onError: controller.addError,
        );
        remoteSub = _remoteDataSource.watch().listen(
          (data) async {
            try {
              await _localDataSource.save(data);
              await _cachePolicy.markFresh('$baseCacheKey');
            } catch (e) {
              logger.warning('Failed to persist remote update: \$e');
            }
          },
          onError: (e) => logger.warning('Remote watch error: \$e'),
        );
      },
      onCancel: () async {
        await remoteSub?.cancel();
        await localSub?.cancel();
      },
    );

    return controller.stream;
  }''';
        } else {
          return '''  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    // Local drives the stream, remote syncs in background
    late final StreamController<$entityName> controller;
    StreamSubscription<$entityName>? localSub;
    StreamSubscription<$entityName>? remoteSub;

    controller = StreamController<$entityName>(
      onListen: () {
        localSub = _localDataSource.watch(params).listen(
          controller.add,
          onError: controller.addError,
        );
        remoteSub = _remoteDataSource.watch(params).listen(
          (data) async {
            try {
              await _localDataSource.save(data);
              await _cachePolicy.markFresh('$baseCacheKey');
            } catch (e) {
              logger.warning('Failed to persist remote update: \$e');
            }
          },
          onError: (e) => logger.warning('Remote watch error: \$e'),
        );
      },
      onCancel: () async {
        await remoteSub?.cancel();
        await localSub?.cancel();
      },
    );

    return controller.stream;
  }''';
        }
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    // Local drives the stream, remote syncs in background
    late final StreamController<List<$entityName>> controller;
    StreamSubscription<List<$entityName>>? localSub;
    StreamSubscription<List<$entityName>>? remoteSub;

    controller = StreamController<List<$entityName>>(
      onListen: () {
        localSub = _localDataSource.watchList(params).listen(
          controller.add,
          onError: controller.addError,
        );
        remoteSub = _remoteDataSource.watchList(params).listen(
          (data) async {
            try {
              await _localDataSource.saveAll(data);
              await _cachePolicy.markFresh('$baseCacheKey');
            } catch (e) {
              logger.warning('Failed to persist remote update: \$e');
            }
          },
          onError: (e) => logger.warning('Remote watch error: \$e'),
        );
      },
      onCancel: () async {
        await remoteSub?.cancel();
        await localSub?.cancel();
      },
    );

    return controller.stream;
  }''';
      default:
        return '';
    }
  }
}
