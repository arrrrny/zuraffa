import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';
import '../utils/string_utils.dart';
import 'usecase_generator.dart';

class VpcGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final UseCaseGenerator useCaseGenerator;

  VpcGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  }) : useCaseGenerator = UseCaseGenerator(
          config: config,
          outputDir: outputDir,
          dryRun: dryRun,
          force: force,
          verbose: verbose,
        );

  Future<GeneratedFile> generatePresenter() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final presenterName = '${entityName}Presenter';
    final fileName = '${entitySnake}_presenter.dart';

    final presenterPathParts = <String>[outputDir, 'presentation', 'pages'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      presenterPathParts.add(config.subdirectory!);
    }
    presenterPathParts.add(entitySnake);
    final presenterDirPath = path.joinAll(presenterPathParts);
    final filePath = path.join(presenterDirPath, fileName);

    final relativePath =
        config.subdirectory != null && config.subdirectory!.isNotEmpty
            ? '../../../'
            : '../../';

    final imports = <String>[
      "import 'package:zuraffa/zuraffa.dart';",
      "import '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';",
    ];

    final repoFields = <String>[];
    final repoParams = <String>[];

    for (final repo in config.effectiveRepos) {
      final repoSnake =
          StringUtils.camelToSnake(repo.replaceAll('Repository', ''));
      final repoCamel = StringUtils.pascalToCamel(repo);
      imports.add(
          "import '$relativePath../domain/repositories/${repoSnake}_repository.dart';");
      repoFields.add('  final $repo $repoCamel;');
      repoParams.add('required this.$repoCamel');
    }

    final useCaseImports = <String>[];
    final useCaseFields = <String>[];
    final useCaseRegistrations = <String>[];
    final presenterMethods = <String>[];

    for (final method in config.methods) {
      final useCaseInfo =
          useCaseGenerator.getUseCaseInfo(method, entityName, entityCamel);
      final useCaseSnake = StringUtils.camelToSnake(
          useCaseInfo.className.replaceAll('UseCase', ''));
      print('Generating use case: ${useCaseInfo.className}');
      print(config.subdirectory);
      final subdirectoryPart =
          config.subdirectory != null && config.subdirectory!.isNotEmpty
              ? '/${config.subdirectory!}'
              : '';
      useCaseImports.add(
          "import '$relativePath../domain/usecases$subdirectoryPart/$entitySnake/${useCaseSnake}_usecase.dart';");
      useCaseFields.add(
          '  late final ${useCaseInfo.className} _${useCaseInfo.fieldName};');

      final mainRepo = config.effectiveRepos.isNotEmpty
          ? StringUtils.pascalToCamel(config.effectiveRepos.first)
          : 'repository';
      useCaseRegistrations.add(
          '    _${useCaseInfo.fieldName} = registerUseCase(${useCaseInfo.className}($mainRepo));');

      presenterMethods.add(useCaseInfo.presenterMethod);
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc

${imports.join('\n')}
${useCaseImports.join('\n')}

class $presenterName extends Presenter {
${repoFields.join('\n')}

${useCaseFields.join('\n')}

  $presenterName({
    ${repoParams.join(',\n    ')},
  }) {
${useCaseRegistrations.join('\n')}
  }

${presenterMethods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'presenter',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateController() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final controllerName = '${entityName}Controller';
    final presenterName = '${entityName}Presenter';
    final stateName = '${entityName}State';
    final fileName = '${entitySnake}_controller.dart';
    String relativePath = '../../';

    final controllerPathParts = <String>[outputDir, 'presentation', 'pages'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      controllerPathParts.add(config.subdirectory!);
      relativePath += '../';
    }

    controllerPathParts.add(entitySnake);
    final controllerDirPath = path.joinAll(controllerPathParts);
    final filePath = path.join(controllerDirPath, fileName);

    final withState = config.generateState;

    final methods = <String>[];

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          methods.add('''
  Future<void> get$entityName(${config.queryFieldType} ${config.queryField}) async {
${withState ? "    updateState(viewState.copyWith(isGetting: true));" : ""}
    final result = await _presenter.get$entityName(${config.queryField});

${withState ? '''    result.fold(
      (entity) => updateState(viewState.copyWith(
        isGetting: false,
        $entityCamel: entity,
      )),
      (failure) => updateState(viewState.copyWith(
        isGetting: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (entity) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'getList':
          methods.add('''
  Future<void> get${entityName}List([ListQueryParams params = const ListQueryParams()]) async {
${withState ? "    updateState(viewState.copyWith(isGettingList: true));" : ""}
    final result = await _presenter.get${entityName}List(params);

${withState ? '''    result.fold(
      (list) => updateState(viewState.copyWith(
        isGettingList: false,
        ${entityCamel}List: list,
      )),
      (failure) => updateState(viewState.copyWith(
        isGettingList: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (list) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'create':
          methods.add('''
  Future<void> create$entityName($entityName $entityCamel) async {
${withState ? "    updateState(viewState.copyWith(isCreating: true));" : ""}
    final result = await _presenter.create$entityName($entityCamel);

${withState ? '''    result.fold(
      (created) => updateState(viewState.copyWith(
        isCreating: false,
        ${entityCamel}List: [...viewState.${entityCamel}List, created],
      )),
      (failure) => updateState(viewState.copyWith(
        isCreating: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (created) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'update':
          final updateDataType = config.useMorphy ? '${entityName}Patch' : 'Partial<$entityName>';
          methods.add('''
  Future<void> update$entityName(${config.idType} ${config.idField}, $updateDataType data) async {
${withState ? "    updateState(viewState.copyWith(isUpdating: true));" : ""}
    final result = await _presenter.update$entityName(${config.idField}, data);

${withState ? '''    result.fold(
      (updated) => updateState(viewState.copyWith(
        isUpdating: false,
        ${entityCamel}List: viewState.${entityCamel}List.map((e) => e.${config.queryField} == updated.${config.queryField} ? updated : e).toList(),
        $entityCamel: viewState.$entityCamel?.${config.queryField} == updated.${config.queryField} ? updated : viewState.$entityCamel,
      )),
      (failure) => updateState(viewState.copyWith(
        isUpdating: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (updated) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'delete':
          methods.add('''
  Future<void> delete$entityName(${config.idType} ${config.idField}) async {
${withState ? "    updateState(viewState.copyWith(isDeleting: true));" : ""}
    final result = await _presenter.delete$entityName(${config.idField});

${withState ? '''    result.fold(
      (_) => updateState(viewState.copyWith(
        isDeleting: false,
        ${entityCamel}List: viewState.${entityCamel}List.where((e) => e.${config.queryField} != ${config.queryField}).toList(),
      )),
      (failure) => updateState(viewState.copyWith(
        isDeleting: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (_) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'watch':
          methods.add('''
  void watch$entityName(${config.queryFieldType}? ${config.queryField}) {
${withState ? "    updateState(viewState.copyWith(isWatching: true));" : ""}
    _presenter.watch$entityName(${config.queryField}).listen(
${withState ? '''      (result) {
        result.fold(
          (entity) => updateState(viewState.copyWith(
            isWatching: false,
            $entityCamel: entity,
          )),
          (failure) => updateState(viewState.copyWith(
            isWatching: false,
            error: failure,
          )),
        );
      },''' : '''      (result) {
        result.fold(
          (entity) {},
          (failure) {},
        );
      },'''}
    );
  }''');
          break;
        case 'watchList':
          methods.add('''
  void watch${entityName}List([ListQueryParams params = const ListQueryParams()]) {
${withState ? "    updateState(viewState.copyWith(isWatchingList: true));" : ""}
    _presenter.watch${entityName}List(params).listen(
${withState ? '''      (result) {
        result.fold(
          (list) => updateState(viewState.copyWith(
            isWatchingList: false,
            ${entityCamel}List: list,
          )),
          (failure) => updateState(viewState.copyWith(
            isWatchingList: false,
            error: failure,
          )),
        );
      },''' : '''      (result) {
        result.fold(
          (list) {},
          (failure) {},
        );
      },'''}
    );
  }''');
          break;
      }
    }

    final imports = <String>[];
    imports.add("import 'package:zuraffa/zuraffa.dart';");
    imports.add("import '${entitySnake}_presenter.dart';");

    if (withState) {
      imports.add("import '${entitySnake}_state.dart';");
    }

    if (config.methods.any((m) => m == 'create' || m == 'update')) {
      final entityPath =
          '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';

      imports.add("import '$entityPath';");
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc${withState ? ' --state' : ''}

${imports.join('\n')}

class $controllerName extends Controller${withState ? ' with StatefulController<$stateName>' : ''} {
  final $presenterName _presenter;

  $controllerName(this._presenter)${withState ? ' : super();' : ';'}

${withState ? '''
  @override
  $stateName createInitialState() => const $stateName();
''' : ''}
${methods.join('\n\n')}

  @override
  void onDisposed() {
    _presenter.dispose();
    super.onDisposed();
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'controller',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateView() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final viewName = '${entityName}View';
    final controllerName = '${entityName}Controller';
    final presenterName = '${entityName}Presenter';
    final fileName = '${entitySnake}_view.dart';
    String relativePath = '../../';

    final viewPathParts = <String>[outputDir, 'presentation', 'pages'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      relativePath += '../';
      viewPathParts.add(config.subdirectory!);
    }
    viewPathParts.add(entitySnake);
    final viewDirPath = path.joinAll(viewPathParts);
    final filePath = path.join(viewDirPath, fileName);

    final repoImports = <String>[];
    final repoFields = <String>[];
    final repoConstructorParams = <String>[];
    final repoPresenterParams = <String>[];

    for (final repo in config.effectiveRepos) {
      final repoSnake =
          StringUtils.camelToSnake(repo.replaceAll('Repository', ''));
      final repoCamel = StringUtils.pascalToCamel(repo);
      repoImports.add(
          "import '$relativePath../domain/repositories/${repoSnake}_repository.dart';");
      repoFields.add('  final $repo $repoCamel;');
      repoConstructorParams.add('required this.$repoCamel');
      repoPresenterParams.add('$repoCamel: $repoCamel');
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc
// ignore_for_file: no_logic_in_create_state

import 'package:flutter/material.dart';
import 'package:zuraffa/zuraffa.dart';
${repoImports.join('\n')}
import '${entitySnake}_controller.dart';
import '${entitySnake}_presenter.dart';

class $viewName extends CleanView {
${repoFields.join('\n')}

  const $viewName({
    super.key,
    super.routeObserver,
    ${repoConstructorParams.join(',\n    ')},
  });

  @override
  State<$viewName> createState() => _${viewName}State(
        $controllerName(
          $presenterName(
            ${repoPresenterParams.join(',\n            ')},
          ),
        ),
      );
}

class _${viewName}State extends CleanViewState<$viewName, $controllerName> {
  _${viewName}State(super.controller);

  @override
  Widget get view {
    return Scaffold(
      key: globalKey,
      appBar: AppBar(
        title: const Text('$entityName'),
      ),
      body: ControlledWidgetBuilder<$controllerName>(
        builder: (context, controller) {
          return Container();
        },
      ),
    );
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'view',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }
}
