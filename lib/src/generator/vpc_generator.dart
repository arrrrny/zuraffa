import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';
import '../utils/string_utils.dart';
import 'usecase_generator.dart';

class VpcGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final UseCaseGenerator useCaseGenerator;

  VpcGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  }) : useCaseGenerator = UseCaseGenerator(
         config: config,
         outputDir: outputDir,
         dryRun: dryRun,
         force: force,
         verbose: verbose,
       );

  Future<GeneratedFile> generatePresenter() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final presenterName = '${entityName}Presenter';
    final fileName = '${entitySnake}_presenter.dart';

    final presenterPathParts = <String>[outputDir, 'presentation', 'pages'];
    presenterPathParts.add(entitySnake);
    final presenterDirPath = path.joinAll(presenterPathParts);
    final filePath = path.join(presenterDirPath, fileName);

    final relativePath = '../../';

    final imports = <String>[
      "import 'package:zuraffa/zuraffa.dart';",
      "import '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';",
    ];

    final repoFields = <String>[];
    final repoParams = <String>[];

    for (final repo in config.effectiveRepos) {
      final repoSnake = StringUtils.camelToSnake(
        repo.replaceAll('Repository', ''),
      );
      final repoCamel = StringUtils.pascalToCamel(repo);
      imports.add(
        "import '$relativePath../domain/repositories/${repoSnake}_repository.dart';",
      );
      repoFields.add('  final $repo $repoCamel;');
      repoParams.add('required this.$repoCamel');
    }

    final useCaseImports = <String>[];
    final useCaseFields = <String>[];
    final useCaseRegistrations = <String>[];
    final presenterMethods = <String>[];

    for (final method in config.methods) {
      final useCaseInfo = useCaseGenerator.getUseCaseInfo(
        method,
        entityName,
        entityCamel,
      );
      final useCaseSnake = StringUtils.camelToSnake(
        useCaseInfo.className.replaceAll('UseCase', ''),
      );
      useCaseImports.add(
        "import '$relativePath../domain/usecases/$entitySnake/${useCaseSnake}_usecase.dart';",
      );
      useCaseFields.add(
        '  late final ${useCaseInfo.className} _${useCaseInfo.fieldName};',
      );

      final mainRepo = config.effectiveRepos.isNotEmpty
          ? StringUtils.pascalToCamel(config.effectiveRepos.first)
          : 'repository';
      useCaseRegistrations.add(
        '    _${useCaseInfo.fieldName} = registerUseCase(${useCaseInfo.className}($mainRepo));',
      );

      presenterMethods.add(useCaseInfo.presenterMethod);
    }

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc

${imports.join('\n')}
${useCaseImports.join('\n')}

class $presenterName extends Presenter {
${repoFields.join('\n')}

${useCaseFields.join('\n')}

  $presenterName({
    ${repoParams.join(',\n    ')},
  }) {
${useCaseRegistrations.join('\n')}
  }

${presenterMethods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'presenter',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateController() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final controllerName = '${entityName}Controller';
    final presenterName = '${entityName}Presenter';
    final stateName = '${entityName}State';
    final fileName = '${entitySnake}_controller.dart';
    String relativePath = '../../';

    final controllerPathParts = <String>[outputDir, 'presentation', 'pages'];

    controllerPathParts.add(entitySnake);
    final controllerDirPath = path.joinAll(controllerPathParts);
    final filePath = path.join(controllerDirPath, fileName);

    final withState = config.generateState;

    final methods = <String>[];

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          final getParams = config.queryFieldType == 'NoParams'
              ? ''
              : '${config.queryFieldType} ${config.queryField}';
          final getArgs = config.queryFieldType == 'NoParams'
              ? ''
              : config.queryField;
          methods.add('''
  Future<void> get$entityName($getParams) async {
${withState ? "    updateState(viewState.copyWith(isGetting: true));" : ""}
    final result = await _presenter.get$entityName($getArgs);

${withState ? '''    result.fold(
      (entity) => updateState(viewState.copyWith(
        isGetting: false,
        $entityCamel: entity,
      )),
      (failure) => updateState(viewState.copyWith(
        isGetting: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (entity) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'getList':
          methods.add('''
  Future<void> get${entityName}List([ListQueryParams<$entityName> params = const ListQueryParams()]) async {
${withState ? "    updateState(viewState.copyWith(isGettingList: true));" : ""}
    final result = await _presenter.get${entityName}List(params);

${withState ? '''    result.fold(
      (list) => updateState(viewState.copyWith(
        isGettingList: false,
        ${entityCamel}List: list,
      )),
      (failure) => updateState(viewState.copyWith(
        isGettingList: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (list) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'create':
          // Only update list optimistically if using getList (not watchList)
          // watchList streams will handle the update automatically
          final hasListMethod = config.methods.contains('getList');
          final hasWatchList = config.methods.contains('watchList');
          final listUpdate = (hasListMethod && !hasWatchList)
              ? '${entityCamel}List: [...viewState.${entityCamel}List, created],'
              : '';
          methods.add('''
  Future<void> create$entityName($entityName $entityCamel) async {
${withState ? "    updateState(viewState.copyWith(isCreating: true));" : ""}
    final result = await _presenter.create$entityName($entityCamel);

${withState ? '''    result.fold(
      (created) => updateState(viewState.copyWith(
        isCreating: false,
        $listUpdate
      )),
      (failure) => updateState(viewState.copyWith(
        isCreating: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (created) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'update':
          final updateDataType = config.useZorphy
              ? '${entityName}Patch'
              : 'Partial<$entityName>';
          final updateParams =
              '${config.idType} ${config.idField}, $updateDataType data';
          final updateArgs = '${config.idField}, data';
          // Only update list optimistically if using getList (not watchList)
          // watchList streams will handle the update automatically
          final hasListMethod = config.methods.contains('getList');
          final hasWatchList = config.methods.contains('watchList');
          final listUpdate = (hasListMethod && !hasWatchList)
              ? '${entityCamel}List: viewState.${entityCamel}List.map((e) => e.${config.queryField} == updated.${config.queryField} ? updated : e).toList(),'
              : '';
          final singleUpdate =
              '$entityCamel: viewState.$entityCamel?.${config.queryField} == updated.${config.queryField} ? updated : viewState.$entityCamel,';
          methods.add('''
  Future<void> update$entityName($updateParams) async {
${withState ? "    updateState(viewState.copyWith(isUpdating: true));" : ""}
    final result = await _presenter.update$entityName($updateArgs);

${withState ? '''    result.fold(
      (updated) => updateState(viewState.copyWith(
        isUpdating: false,
        $listUpdate
        $singleUpdate
      )),
      (failure) => updateState(viewState.copyWith(
        isUpdating: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (updated) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'delete':
          final deleteParams = '${config.idType} ${config.idField}';
          final deleteArgs = config.idField;
          // Delete should ALWAYS update optimistically for immediate UI feedback
          // This prevents Dismissible errors and provides better UX
          final hasListMethod =
              config.methods.contains('getList') ||
              config.methods.contains('watchList');
          final listUpdate = hasListMethod
              ? '${entityCamel}List: viewState.${entityCamel}List.where((e) => e.${config.queryField} != ${config.queryField}).toList(),'
              : '';
          methods.add('''
  Future<void> delete$entityName($deleteParams) async {
${withState ? '''    // Immediately remove from list for optimistic UI update
    // This prevents Dismissible error where widget must be removed synchronously
    updateState(viewState.copyWith(
      isDeleting: true,
      $listUpdate
    ));

    final result = await _presenter.delete$entityName($deleteArgs);

    result.fold(
      (_) => updateState(viewState.copyWith(isDeleting: false)),
      (failure) => updateState(viewState.copyWith(
        isDeleting: false,
        error: failure,
      )),
    );''' : '''    final result = await _presenter.delete$entityName($deleteArgs);

    result.fold(
      (_) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'watch':
          final watchParams = config.queryFieldType == 'NoParams'
              ? ''
              : '${config.queryFieldType} ${config.queryField}';
          final watchArgs = config.queryFieldType == 'NoParams'
              ? ''
              : config.queryField;
          methods.add('''
  void watch$entityName($watchParams) {
${withState ? "    updateState(viewState.copyWith(isWatching: true));" : ""}
    _presenter.watch$entityName($watchArgs).listen(
${withState ? '''      (result) {
        result.fold(
          (entity) => updateState(viewState.copyWith(
            isWatching: false,
            $entityCamel: entity,
          )),
          (failure) => updateState(viewState.copyWith(
            isWatching: false,
            error: failure,
          )),
        );
      },''' : '''      (result) {
        result.fold(
          (entity) {},
          (failure) {},
        );
      },'''}
    );
  }''');
          break;
        case 'watchList':
          methods.add('''
  void watch${entityName}List([ListQueryParams<$entityName> params = const ListQueryParams()]) {
${withState ? "    updateState(viewState.copyWith(isWatchingList: true));" : ""}
    _presenter.watch${entityName}List(params).listen(
${withState ? '''      (result) {
        result.fold(
          (list) => updateState(viewState.copyWith(
            isWatchingList: false,
            ${entityCamel}List: list,
          )),
          (failure) => updateState(viewState.copyWith(
            isWatchingList: false,
            error: failure,
          )),
        );
      },''' : '''      (result) {
        result.fold(
          (list) {},
          (failure) {},
        );
      },'''}
    );
  }''');
          break;
      }
    }

    final imports = <String>[];
    imports.add("import 'package:zuraffa/zuraffa.dart';");
    imports.add("import '${entitySnake}_presenter.dart';");

    if (withState) {
      imports.add("import '${entitySnake}_state.dart';");
    }

    if (config.methods.any(
      (m) =>
          m == 'create' || m == 'update' || m == 'getList' || m == 'watchList',
    )) {
      final entityPath =
          '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';

      imports.add("import '$entityPath';");
    }

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc${withState ? ' --state' : ''}

${imports.join('\n')}

class $controllerName extends Controller${withState ? ' with StatefulController<$stateName>' : ''} {
  final $presenterName _presenter;

  $controllerName(this._presenter)${withState ? ' : super();' : ';'}

${withState ? '''
  @override
  $stateName createInitialState() => const $stateName();
''' : ''}
${methods.join('\n\n')}

  @override
  void onDisposed() {
    _presenter.dispose();
    super.onDisposed();
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'controller',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateView() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final viewName = '${entityName}View';
    final controllerName = '${entityName}Controller';
    final presenterName = '${entityName}Presenter';
    final fileName = '${entitySnake}_view.dart';
    String relativePath = '../../';

    final viewPathParts = <String>[outputDir, 'presentation', 'pages'];
    viewPathParts.add(entitySnake);
    final viewDirPath = path.joinAll(viewPathParts);
    final filePath = path.join(viewDirPath, fileName);

    final repoImports = <String>[];
    final repoFields = <String>[];
    final repoConstructorParams = <String>[];
    final repoPresenterParams = <String>[];

    for (final repo in config.effectiveRepos) {
      final repoSnake = StringUtils.camelToSnake(
        repo.replaceAll('Repository', ''),
      );
      final repoCamel = StringUtils.pascalToCamel(repo);
      repoImports.add(
        "import '$relativePath../domain/repositories/${repoSnake}_repository.dart';",
      );
      repoFields.add('  final $repo $repoCamel;');
      repoConstructorParams.add('required this.$repoCamel');
      repoPresenterParams.add('$repoCamel: $repoCamel');
    }

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc
// ignore_for_file: no_logic_in_create_state

import 'package:flutter/material.dart';
import 'package:zuraffa/zuraffa.dart';
${repoImports.join('\n')}
import '${entitySnake}_controller.dart';
import '${entitySnake}_presenter.dart';

class $viewName extends CleanView {
${repoFields.join('\n')}

  const $viewName({
    super.key,
    super.routeObserver,
    ${repoConstructorParams.join(',\n    ')},
  });

  @override
  State<$viewName> createState() => _${viewName}State(
        $controllerName(
          $presenterName(
            ${repoPresenterParams.join(',\n            ')},
          ),
        ),
      );
}

class _${viewName}State extends CleanViewState<$viewName, $controllerName> {
  _${viewName}State(super.controller);

  @override
  void onInitState() {
    super.onInitState();
    ${config.methods.contains('getList')
            ? 'controller.get${entityName}List();'
            : config.methods.contains('watchList')
            ? 'controller.watch${entityName}List();'
            : config.methods.contains('get')
            ? (config.queryFieldType == 'NoParams' ? 'controller.get$entityName();' : '//TODO: pass the id of the $entityName\n    //controller.get$entityName(/* ${config.queryField} */);')
            : config.methods.contains('watch')
            ? (config.queryFieldType == 'NoParams' ? 'controller.watch$entityName();' : '//TODO: pass the id of the $entityName\n    //controller.watch$entityName(/* ${config.queryField} */);')
            : '// No initial method found'}
  }

  @override
  Widget get view {
    return Scaffold(
      key: globalKey,
      appBar: AppBar(
        title: const Text('$entityName'),
      ),
      body: ControlledWidgetBuilder<$controllerName>(
        builder: (context, controller) {
          return Container();
        },
      ),
    );
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'view',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }
}
