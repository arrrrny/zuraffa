import 'package:path/path.dart' as path;
import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/file_utils.dart';
import '../utils/string_utils.dart';
import 'usecase_generator.dart';

class VpcGenerator {
  final GeneratorConfig config;
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final UseCaseGenerator useCaseGenerator;

  VpcGenerator({
    required this.config,
    required this.outputDir,
    this.dryRun = false,
    this.force = false,
    this.verbose = false,
  }) : useCaseGenerator = UseCaseGenerator(
          config: config,
          outputDir: outputDir,
          dryRun: dryRun,
          force: force,
          verbose: verbose,
        );

  Future<GeneratedFile> generatePresenter() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final presenterName = '${entityName}Presenter';
    final fileName = '${entitySnake}_presenter.dart';

    final presenterPathParts = <String>[outputDir, 'presentation', 'pages'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      presenterPathParts.add(config.subdirectory!);
    }
    presenterPathParts.add(entitySnake);
    final presenterDirPath = path.joinAll(presenterPathParts);
    final filePath = path.join(presenterDirPath, fileName);

    final relativePath =
        config.subdirectory != null && config.subdirectory!.isNotEmpty
            ? '../../../'
            : '../../';

    final imports = <String>[
      "import 'package:zuraffa/zuraffa.dart';",
    ];

    final useCaseInfos = <UseCaseInfo>[];
    final fields = <String>[];
    final constructorParams = <String>[];
    final methods = <String>[];

    for (final method in config.methods) {
      final useCaseInfo =
          useCaseGenerator.getUseCaseInfo(method, entityName, entityCamel);
      useCaseInfos.add(useCaseInfo);
      fields.add('  final ${useCaseInfo.className} _${useCaseInfo.fieldName};');
      constructorParams
          .add('required ${useCaseInfo.className} ${useCaseInfo.fieldName}');
      methods.add(useCaseInfo.presenterMethod);
    }

    // Add repository imports
    for (final repo in config.effectiveRepos) {
      final repoSnake =
          StringUtils.camelToSnake(repo.replaceAll('Repository', ''));
      imports.add(
          "import '$relativePath../domain/repositories/${repoSnake}_repository.dart';");
    }

    // Add entity import if needed
    if (config.methods
        .any((m) => ['create', 'update', 'get', 'watch'].contains(m))) {
      imports.add(
          "import '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';");
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc

${imports.join('\n')}

class $presenterName with Disposable {
${fields.join('\n')}

  $presenterName({
    ${constructorParams.join(',\n    ')},
  }) : ${fields.map((f) => '_${f.split(' ').last.replaceAll(';', '')} = ${f.split(' ').last.replaceAll(';', '')}').join(',\n       ')};

${methods.join('\n\n')}

  @override
  void dispose() {
    // Dispose resources if needed
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'presenter',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateController() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final controllerName = '${entityName}Controller';
    final presenterName = '${entityName}Presenter';
    final stateName = '${entityName}State';
    final fileName = '${entitySnake}_controller.dart';
    final withState = config.generateState;

    final controllerPathParts = <String>[outputDir, 'presentation', 'pages'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      controllerPathParts.add(config.subdirectory!);
    }
    controllerPathParts.add(entitySnake);
    final controllerDirPath = path.joinAll(controllerPathParts);
    final filePath = path.join(controllerDirPath, fileName);

    final methods = <String>[];

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null') {
            methods.add('''
  Future<void> get$entityName() async {
${withState ? "    updateState(viewState.copyWith(isGetting: true));" : ""}
    final result = await _presenter.get$entityName();

${withState ? '''    result.fold(
      (entity) => updateState(viewState.copyWith(
        isGetting: false,
        $entityCamel: entity,
      )),
      (failure) => updateState(viewState.copyWith(
        isGetting: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (entity) {},
      (failure) {},
    );'''}
  }''');
          } else {
            methods.add('''
  Future<void> get$entityName(${config.queryFieldType} ${config.queryField}) async {
${withState ? "    updateState(viewState.copyWith(isGetting: true));" : ""}
    final result = await _presenter.get$entityName(${config.queryField});

${withState ? '''    result.fold(
      (entity) => updateState(viewState.copyWith(
        isGetting: false,
        $entityCamel: entity,
      )),
      (failure) => updateState(viewState.copyWith(
        isGetting: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (entity) {},
      (failure) {},
    );'''}
  }''');
          }
          break;
        case 'getList':
          methods.add('''
  Future<void> get${entityName}List([ListQueryParams params = const ListQueryParams()]) async {
${withState ? "    updateState(viewState.copyWith(isGettingList: true));" : ""}
    final result = await _presenter.get${entityName}List(params);

${withState ? '''    result.fold(
      (list) => updateState(viewState.copyWith(
        isGettingList: false,
        ${entityCamel}List: list,
      )),
      (failure) => updateState(viewState.copyWith(
        isGettingList: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (list) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'create':
          methods.add('''
  Future<void> create$entityName($entityName $entityCamel) async {
${withState ? "    updateState(viewState.copyWith(isCreating: true));" : ""}
    final result = await _presenter.create$entityName($entityCamel);

${withState ? '''    result.fold(
      (created) => updateState(viewState.copyWith(
        isCreating: false,
        ${entityCamel}List: [...viewState.${entityCamel}List, created],
      )),
      (failure) => updateState(viewState.copyWith(
        isCreating: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (created) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'update':
          final updateDataType =
              config.useMorphy ? '${entityName}Patch' : 'Partial<$entityName>';
          methods.add('''
  Future<void> update$entityName(${config.idType} ${config.idField}, $updateDataType data) async {
${withState ? "    updateState(viewState.copyWith(isUpdating: true));" : ""}
    final result = await _presenter.update$entityName(${config.idField}, data);

${withState ? '''    result.fold(
      (updated) => updateState(viewState.copyWith(
        isUpdating: false,
        ${entityCamel}List: viewState.${entityCamel}List.map((e) => e.${config.queryField} == updated.${config.queryField} ? updated : e).toList(),
        $entityCamel: viewState.$entityCamel?.${config.queryField} == updated.${config.queryField} ? updated : viewState.$entityCamel,
      )),
      (failure) => updateState(viewState.copyWith(
        isUpdating: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (updated) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'delete':
          methods.add('''
  Future<void> delete$entityName(${config.idType} ${config.idField}) async {
${withState ? "    updateState(viewState.copyWith(isDeleting: true));" : ""}
    final result = await _presenter.delete$entityName(${config.idField});

${withState ? '''    result.fold(
      (_) => updateState(viewState.copyWith(
        isDeleting: false,
        ${entityCamel}List: viewState.${entityCamel}List.where((e) => e.${config.queryField} != ${config.queryField}).toList(),
      )),
      (failure) => updateState(viewState.copyWith(
        isDeleting: false,
        error: failure,
      )),
    );''' : '''    result.fold(
      (_) {},
      (failure) {},
    );'''}
  }''');
          break;
        case 'watch':
          if (config.idField == 'null') {
            methods.add('''
  void watch$entityName() {
    _presenter.watch$entityName().listen((result) {
${withState ? '''      result.fold(
        (entity) => updateState(viewState.copyWith($entityCamel: entity)),
        (failure) => updateState(viewState.copyWith(error: failure)),
      );''' : '''      result.fold(
        (entity) {},
        (failure) {},
      );'''}
    });
  }''');
          } else {
            methods.add('''
  void watch$entityName(${config.queryFieldType} ${config.queryField}) {
    _presenter.watch$entityName(${config.queryField}).listen((result) {
${withState ? '''      result.fold(
        (entity) => updateState(viewState.copyWith($entityCamel: entity)),
        (failure) => updateState(viewState.copyWith(error: failure)),
      );''' : '''      result.fold(
        (entity) {},
        (failure) {},
      );'''}
    });
  }''');
          }
          break;
        case 'watchList':
          methods.add('''
  void watch${entityName}List([ListQueryParams params = const ListQueryParams()]) {
    _presenter.watch${entityName}List(params).listen((result) {
${withState ? '''      result.fold(
        (list) => updateState(viewState.copyWith(${entityCamel}List: list)),
        (failure) => updateState(viewState.copyWith(error: failure)),
      );''' : '''      result.fold(
        (list) {},
        (failure) {},
      );'''}
    });
  }''');
          break;
      }
    }

    final imports = <String>[];
    imports.add("import 'package:zuraffa/zuraffa.dart';");
    imports.add("import '${entitySnake}_presenter.dart';");

    if (withState) {
      imports.add("import '${entitySnake}_state.dart';");
    }

    if (config.methods.any((m) => m == 'create' || m == 'update')) {
      final relativePath =
          config.subdirectory != null && config.subdirectory!.isNotEmpty
              ? '../../../'
              : '../../';
      final entityPath =
          '$relativePath../domain/entities/$entitySnake/$entitySnake.dart';
      imports.add("import '$entityPath';");
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc${withState ? ' --state' : ''}

${imports.join('\n')}

class $controllerName extends Controller${withState ? ' with StatefulController<$stateName>' : ''} {
  final $presenterName _presenter;

  $controllerName(this._presenter)${withState ? ' : super();' : ';'}

${withState ? '''
  @override
  $stateName createInitialState() => const $stateName();
''' : ''}
${methods.join('\n\n')}

  @override
  void onDisposed() {
    _presenter.dispose();
    super.onDisposed();
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'controller',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  Future<GeneratedFile> generateView() async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final viewName = '${entityName}View';
    final controllerName = '${entityName}Controller';
    final presenterName = '${entityName}Presenter';
    final fileName = '${entitySnake}_view.dart';
    String relativePath = '../../';

    final viewPathParts = <String>[outputDir, 'presentation', 'pages'];
    if (config.subdirectory != null && config.subdirectory!.isNotEmpty) {
      relativePath += '../';
      viewPathParts.add(config.subdirectory!);
    }
    viewPathParts.add(entitySnake);
    final viewDirPath = path.joinAll(viewPathParts);
    final filePath = path.join(viewDirPath, fileName);

    final repoImports = <String>[];
    final repoFields = <String>[];
    final repoConstructorParams = <String>[];
    final repoPresenterParams = <String>[];

    for (final repo in config.effectiveRepos) {
      final repoSnake =
          StringUtils.camelToSnake(repo.replaceAll('Repository', ''));
      final repoCamel = StringUtils.pascalToCamel(repo);
      repoImports.add(
          "import '$relativePath../domain/repositories/${repoSnake}_repository.dart';");
      repoFields.add('  final $repo $repoCamel;');
      repoConstructorParams.add('required this.$repoCamel');
      repoPresenterParams.add('$repoCamel: $repoCamel');
    }

    // Determine initial method call
    String initialMethodCall = '// No initial method found';
    if (config.methods.contains('getList')) {
      initialMethodCall = 'controller.get${entityName}List();';
    } else if (config.methods.contains('watchList')) {
      initialMethodCall = 'controller.watch${entityName}List();';
    } else if (config.methods.contains('get')) {
      if (config.idField == 'null') {
        initialMethodCall = 'controller.get$entityName();';
      } else {
        initialMethodCall =
            'controller.get$entityName(/* ${config.queryField} */);';
      }
    } else if (config.methods.contains('watch')) {
      if (config.idField == 'null') {
        initialMethodCall = 'controller.watch$entityName();';
      } else {
        initialMethodCall =
            'controller.watch$entityName(/* ${config.queryField} */);';
      }
    }

    final content = '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --vpc
// ignore_for_file: no_logic_in_create_state

import 'package:flutter/material.dart';
import 'package:zuraffa/zuraffa.dart';
${repoImports.join('\n')}
import '${entitySnake}_controller.dart';
import '${entitySnake}_presenter.dart';

class $viewName extends CleanView {
${repoFields.join('\n')}

  const $viewName({
    super.key,
    super.routeObserver,
    ${repoConstructorParams.join(',\n    ')},
  });

  @override
  State<$viewName> createState() => _${viewName}State(
        $controllerName(
          $presenterName(
            ${repoPresenterParams.join(',\n            ')},
          ),
        ),
      );
}

class _${viewName}State extends CleanViewState<$viewName, $controllerName> {
  _${viewName}State(super.controller);

  @override
  void onInitState() {
    super.onInitState();
    $initialMethodCall
  }

  @override
  Widget get view {
    return Scaffold(
      key: globalKey,
      appBar: AppBar(
        title: const Text('$entityName'),
      ),
      body: ControlledWidgetBuilder<$controllerName>(
        builder: (context, controller) {
          return Container();
        },
      ),
    );
  }
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'view',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }
}
