// Generated by zfa

import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/string_utils.dart';
import '../utils/entity_analyzer.dart';
import '../utils/file_utils.dart';

class MockGenerator {
  static Future<List<GeneratedFile>> generate(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final files = <GeneratedFile>[];

    // Generate mock data file for main entity
    final mockDataFile = await _generateMockDataFile(config, outputDir,
        dryRun: dryRun, force: force, verbose: verbose);
    files.add(mockDataFile);

    // Generate mock data files for nested entities
    final nestedEntityFiles = await _generateNestedEntityMockFiles(
        config, outputDir,
        dryRun: dryRun, force: force, verbose: verbose);
    files.addAll(nestedEntityFiles);

    // Generate mock data source if not mock-data-only
    if (!config.generateMockDataOnly) {
      final mockDataSourceFile = await _generateMockDataSource(
          config, outputDir,
          dryRun: dryRun, force: force, verbose: verbose);
      files.add(mockDataSourceFile);
    }

    return files;
  }

  static Future<List<GeneratedFile>> _generateNestedEntityMockFiles(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final files = <GeneratedFile>[];
    final entityName = config.name;
    final entityFields = EntityAnalyzer.analyzeEntity(entityName, outputDir);
    final processedEntities = <String>{
      entityName
    }; // Avoid generating for main entity

    await _collectAndGenerateNestedEntities(
        entityFields, outputDir, files, processedEntities,
        dryRun: dryRun, force: force, verbose: verbose);

    return files;
  }

  static Future<void> _collectAndGenerateNestedEntities(
    Map<String, String> fields,
    String outputDir,
    List<GeneratedFile> files,
    Set<String> processedEntities, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    for (final entry in fields.entries) {
      final fieldType = entry.value;
      var baseType = fieldType
          .replaceAll('?', '')
          .replaceAll('List<', '')
          .replaceAll('>', '');

      // Handle morphy entity indicator ($EntityName)
      if (baseType.startsWith('\$')) {
        baseType = baseType.substring(1);
      }

      // Check if it's a custom type (PascalCase) and not already processed
      if (baseType.isNotEmpty &&
          baseType[0] == baseType[0].toUpperCase() &&
          !processedEntities.contains(baseType)) {
        // Check if it's an entity (has fields)
        final entityFields = EntityAnalyzer.analyzeEntity(baseType, outputDir);
        if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
          processedEntities.add(baseType);

          if (verbose) {
            print('  → Generating mock for nested entity: $baseType');
          }

          // Generate mock data file for this nested entity
          final nestedConfig =
              GeneratorConfig(name: baseType, generateMockDataOnly: true);
          final nestedMockFile = await _generateMockDataFile(
              nestedConfig, outputDir,
              dryRun: dryRun, force: force, verbose: verbose);
          files.add(nestedMockFile);

          // Recursively process nested entities within this entity
          await _collectAndGenerateNestedEntities(
              entityFields, outputDir, files, processedEntities,
              dryRun: dryRun, force: force, verbose: verbose);
        } else if (verbose) {
          print('  → Skipping $baseType (not an entity or default fields)');
        }
      }
    }
  }

  static bool _isDefaultFields(Map<String, String> fields) {
    // Check if these are the default fallback fields
    final defaultKeys = {
      'id',
      'name',
      'description',
      'price',
      'category',
      'isActive',
      'createdAt',
      'updatedAt'
    };
    return fields.keys.toSet().containsAll(defaultKeys);
  }

  static List<String> _collectNestedEntityImports(
      Map<String, String> fields, String outputDir) {
    final imports = <String>[];
    bool hasEnums = false;

    for (final entry in fields.entries) {
      final fieldType = entry.value;

      // Extract base type from complex types
      var baseType = fieldType.replaceAll('?', '');

      // Handle List<Type>
      if (baseType.startsWith('List<') && baseType.endsWith('>')) {
        baseType = baseType.substring(5, baseType.length - 1);
      }

      // Handle Map<K,V> - skip entirely as they don't need entity imports
      if (baseType.startsWith('Map<')) {
        continue; // Skip Map types completely
      }

      // Handle morphy entity indicator ($EntityName)
      if (baseType.startsWith('\$')) {
        baseType = baseType.substring(1);
      }

      // Skip primitive types
      if (['String', 'int', 'double', 'bool', 'DateTime', 'Object']
          .contains(baseType)) {
        continue;
      }

      // Check if it's a custom type (PascalCase)
      if (baseType.isNotEmpty && baseType[0] == baseType[0].toUpperCase()) {
        // Check if it's an entity (has fields)
        final entityFields = EntityAnalyzer.analyzeEntity(baseType, outputDir);
        if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
          final entitySnake = StringUtils.camelToSnake(baseType);
          // Import the mock data file
          imports.add('../mock/${entitySnake}_mock_data.dart');
        } else {
          // It's likely an enum - only add import if this entity directly uses it
          hasEnums = true;
        }
      }
    }

    // Add single enum import only if this entity directly has enum fields
    if (hasEnums) {
      imports.insert(0, '../../domain/entities/enums/index.dart');
    }

    return imports.toSet().toList(); // Remove duplicates
  }

  static Future<GeneratedFile> _generateMockDataFile(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final entityName = config.name;
    final entitySnake = StringUtils.camelToSnake(entityName);
    final entityCamel = StringUtils.pascalToCamel(entityName);

    // Try to analyze entity for realistic mock data
    final entityFields = EntityAnalyzer.analyzeEntity(entityName, outputDir);

    final mockData =
        _generateMockDataInstances(entityName, entityFields, outputDir);

    // Collect imports for nested entities
    final imports = _collectNestedEntityImports(entityFields, outputDir);
    final importStatements =
        imports.map((import) => "import '$import';").join('\n');

    final content = '''
// Generated by zfa
// Mock data for $entityName

import '../../domain/entities/$entitySnake/$entitySnake.dart';
${importStatements.isNotEmpty ? '$importStatements\n' : ''}
class ${entityName}MockData {
  static final List<$entityName> ${entityCamel}s = [
$mockData
  ];

  static $entityName get sample$entityName => ${entityCamel}s.first;
  static List<$entityName> get sampleList => ${entityCamel}s;
  static List<$entityName> get emptyList => [];

  static List<$entityName> get large${entityName}List => List.generate(
    100,
    (index) => _create$entityName(index + 1000),
  );

  static $entityName _create$entityName(int seed) {
    return $entityName(
${_generateConstructorCall(entityFields, useSeeds: true, outputDir: outputDir)}
    );
  }
}
''';

    final filePath = '$outputDir/data/mock/${entitySnake}_mock_data.dart';
    return FileUtils.writeFile(
      filePath,
      content,
      'mock_data',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  static Future<GeneratedFile> _generateMockDataSource(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final entityName = config.name;
    final entitySnake = StringUtils.camelToSnake(entityName);
    final entityCamel = StringUtils.pascalToCamel(entityName);

    final methods =
        _generateMockDataSourceMethods(config, entityName, entityCamel);

    final content = '''
// Generated by zfa
// Mock data source for $entityName

import 'dart:async';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/$entitySnake/$entitySnake.dart';
import '../../mock/${entitySnake}_mock_data.dart';
import '${entitySnake}_data_source.dart';

class ${entityName}MockDataSource with Loggable, FailureHandler implements ${entityName}DataSource {
  final Duration _delay;

  ${entityName}MockDataSource({Duration? delay})
    : _delay = delay ?? const Duration(milliseconds: 100);

${config.generateInit ? '''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing ${entityName}MockDataSource');
    // Mock initialization - nothing to do
    await Future.delayed(const Duration(seconds: 1));
    logger.info('${entityName}MockDataSource initialized');
  }

  @override
  Stream<bool> get isInitialized => Stream.value(true);

''' : ''}$methods
}
''';

    final filePath =
        '$outputDir/data/data_sources/$entitySnake/${entitySnake}_mock_data_source.dart';
    return FileUtils.writeFile(
      filePath,
      content,
      'mock_data_source',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  static String _generateMockDataInstances(
      String entityName, Map<String, String> fields, String outputDir) {
    final instances = <String>[];

    // Generate 3 instances
    for (int i = 1; i <= 3; i++) {
      instances.add('''    $entityName(
${_generateConstructorCall(fields, seed: i, outputDir: outputDir)}
    ),''');
    }

    return instances.join('\n');
  }

  static String _generateConstructorCall(Map<String, String> fields,
      {int seed = 1, bool useSeeds = false, required String outputDir}) {
    final params = <String>[];

    for (final entry in fields.entries) {
      final fieldName = entry.key;
      final fieldType = entry.value;
      final mockValue =
          _generateMockValue(fieldName, fieldType, seed, useSeeds, outputDir);
      params.add('      $fieldName: $mockValue,');
    }

    return params.join('\n');
  }

  static String _generateMockValue(String fieldName, String fieldType, int seed,
      bool useSeeds, String outputDir) {
    // Handle nullable types
    final isNullable = fieldType.endsWith('?');
    final baseType = fieldType.replaceAll('?', '');

    if (useSeeds) {
      return _generateSeededValue(fieldName, baseType, isNullable, outputDir);
    }

    // Generate values ONLY based on field type
    switch (baseType) {
      case 'String':
        return "'$fieldName $seed'";

      case 'int':
        return '${seed * 10}';

      case 'double':
        return '${seed * 10.5}';

      case 'bool':
        return seed % 2 == 1 ? 'true' : 'false';

      case 'DateTime':
        return 'DateTime.now().subtract(Duration(days: ${seed * 30}))';

      case 'Object':
        return '{"key$seed": "value$seed"}';

      default:
        // Handle List types
        if (baseType.startsWith('List<') && baseType.endsWith('>')) {
          final listType = baseType.substring(5, baseType.length - 1);
          return _generateListValue(listType, seed, outputDir);
        }

        // Handle Map types
        if (baseType.startsWith('Map<') && baseType.endsWith('>')) {
          return _generateMapValue(baseType, seed);
        }

        // Handle custom classes/enums
        if (isNullable && seed % 3 == 0) return 'null';

        // Check if it's likely an enum or class
        if (baseType.isNotEmpty && baseType[0] == baseType[0].toUpperCase()) {
          // Try to detect if it's an entity by checking if it has fields
          final entityFields =
              EntityAnalyzer.analyzeEntity(baseType, outputDir);
          if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
            // It's an entity - reference its mock data
            return '${baseType}MockData.sample$baseType';
          }
          // Otherwise treat as enum
          return '$baseType.values[${seed % 3}]';
        }

        return "'$fieldName $seed'";
    }
  }

  static String _generateListValue(
      String listType, int seed, String outputDir) {
    // Handle morphy entity indicator ($EntityName)
    final cleanListType =
        listType.startsWith('\$') ? listType.substring(1) : listType;

    // Generate a list with 2-3 items
    final itemCount = 2 + (seed % 2);
    final items = <String>[];

    for (int i = 1; i <= itemCount; i++) {
      // Check if listType is an entity
      if (cleanListType.isNotEmpty &&
          cleanListType[0] == cleanListType[0].toUpperCase()) {
        final entityFields =
            EntityAnalyzer.analyzeEntity(cleanListType, outputDir);
        if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
          // Reference different items from the mock data
          final itemIndex = (seed + i - 1) % 3;
          items.add(
              '${cleanListType}MockData.${StringUtils.pascalToCamel(cleanListType)}s[$itemIndex]');
          continue;
        }
      }

      // For primitive types or enums
      final itemValue =
          _generateMockValue('item', cleanListType, seed + i, false, outputDir);
      items.add(itemValue);
    }

    return '[${items.join(', ')}]';
  }

  static String _generateMapValue(String mapType, int seed) {
    // Extract key and value types from Map<K, V>
    final innerTypes =
        mapType.substring(4, mapType.length - 1); // Remove "Map<" and ">"
    final typeParts = innerTypes.split(',').map((s) => s.trim()).toList();

    if (typeParts.length != 2) {
      return '{}'; // Fallback for malformed map types
    }

    final keyType = typeParts[0];
    final valueType = typeParts[1];

    // Generate 2-3 key-value pairs
    final itemCount = 2 + (seed % 2);
    final entries = <String>[];

    for (int i = 1; i <= itemCount; i++) {
      final keyValue = _generateSimpleValue(keyType, 'key$i', seed + i);
      final valueValue = _generateSimpleValue(valueType, 'value$i', seed + i);
      entries.add('$keyValue: $valueValue');
    }

    return '{${entries.join(', ')}}';
  }

  static String _generateSimpleValue(String type, String name, int seed) {
    switch (type) {
      case 'String':
        return "'$name'";
      case 'int':
        return '${seed * 10}';
      case 'double':
        return '${seed * 10.5}';
      case 'bool':
        return seed % 2 == 1 ? 'true' : 'false';
      default:
        return "'$name'"; // Fallback to string
    }
  }

  static String _generateSeededValue(
      String fieldName, String baseType, bool isNullable, String outputDir) {
    switch (baseType) {
      case 'String':
        return "'$fieldName \$seed'";
      case 'int':
        return 'seed * 10';
      case 'double':
        return 'seed * 10.5';
      case 'bool':
        return 'seed % 2 == 1';
      case 'DateTime':
        return 'DateTime.now().subtract(Duration(days: seed * 30))';
      case 'Object':
        return '{"key\$seed": "value\$seed"}';
      default:
        // Handle List types
        if (baseType.startsWith('List<') && baseType.endsWith('>')) {
          final listType = baseType.substring(5, baseType.length - 1);
          return _generateSeededListValue(listType, outputDir);
        }

        // Handle Map types
        if (baseType.startsWith('Map<') && baseType.endsWith('>')) {
          return _generateSeededMapValue(baseType);
        }

        // Handle custom classes/enums
        if (baseType.isNotEmpty && baseType[0] == baseType[0].toUpperCase()) {
          // Handle morphy entity indicator ($EntityName)
          final cleanType =
              baseType.startsWith('\$') ? baseType.substring(1) : baseType;

          // Try to detect if it's an entity by checking if it has fields
          final entityFields =
              EntityAnalyzer.analyzeEntity(cleanType, outputDir);
          if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
            // It's an entity - reference its mock data
            return '${cleanType}MockData.sample$cleanType';
          }
          // Otherwise treat as enum
          return '$cleanType.values[seed % 3]';
        }
        return "'$fieldName \$seed'";
    }
  }

  static String _generateSeededListValue(String listType, String outputDir) {
    // Handle morphy entity indicator ($EntityName)
    final cleanListType =
        listType.startsWith('\$') ? listType.substring(1) : listType;

    // Check if listType is an entity
    if (cleanListType.isNotEmpty &&
        cleanListType[0] == cleanListType[0].toUpperCase()) {
      final entityFields =
          EntityAnalyzer.analyzeEntity(cleanListType, outputDir);
      if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
        // Reference mock data items
        return '[${cleanListType}MockData.${StringUtils.pascalToCamel(cleanListType)}s[0], ${cleanListType}MockData.${StringUtils.pascalToCamel(cleanListType)}s[1]]';
      }
    }

    // For primitive types, generate simple values
    switch (cleanListType) {
      case 'String':
        return "['item \$seed', 'item \$seed']";
      case 'int':
        return '[\$seed, \$seed + 1]';
      case 'double':
        return '[\$seed * 1.5, \$seed * 2.5]';
      case 'bool':
        return '[true, false]';
      default:
        return '[$cleanListType(), $cleanListType()]';
    }
  }

  static String _generateSeededMapValue(String mapType) {
    // Extract key and value types from Map<K, V>
    final innerTypes =
        mapType.substring(4, mapType.length - 1); // Remove "Map<" and ">"
    final typeParts = innerTypes.split(',').map((s) => s.trim()).toList();

    if (typeParts.length != 2) {
      return '{}'; // Fallback for malformed map types
    }

    final keyType = typeParts[0];
    final valueType = typeParts[1];

    // Generate seeded key-value pairs
    final keyValue = _generateSeededSimpleValue(keyType, 'key');
    final valueValue = _generateSeededSimpleValue(valueType, 'value');

    return '{$keyValue: $valueValue, $keyValue: $valueValue}';
  }

  static String _generateSeededSimpleValue(String type, String name) {
    switch (type) {
      case 'String':
        return "'$name \$seed'";
      case 'int':
        return 'seed * 10';
      case 'double':
        return 'seed * 10.5';
      case 'bool':
        return 'seed % 2 == 1';
      default:
        return "'$name \$seed'"; // Fallback to string
    }
  }

  static String _generateMockDataSourceMethods(
      GeneratorConfig config, String entityName, String entityCamel) {
    final methods = <String>[];

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          methods.add('''
  @override
  Future<$entityName> get(String id) async {
    logger.info('Getting $entityName with id: \$id');
    await Future.delayed(_delay);
    final item = ${entityName}MockData.${entityCamel}s.firstWhere(
      (item) => item.id == id,
      orElse: () => throw NotFoundFailure('$entityName not found: \$id'),
    );
    logger.info('Successfully retrieved $entityName: \$id');
    return item;
  }''');
          break;

        case 'getList':
          methods.add('''
  @override
  Future<List<$entityName>> getList(ListQueryParams params) async {
    logger.info('Getting $entityName list with params: \$params');
    await Future.delayed(_delay);
    var items = ${entityName}MockData.${entityCamel}s;

    // Apply limit if specified
    if (params.limit != null && params.limit! > 0) {
      items = items.take(params.limit!).toList();
    }

    logger.info('Successfully retrieved \${items.length} ${entityName}s');
    return items;
  }''');
          break;

        case 'create':
          methods.add('''
  @override
  Future<$entityName> create($entityName item) async {
      logger.info('Creating $entityName: \${item.id}');
      await Future.delayed(_delay);
      // In a real implementation, you'd add to storage
      logger.info('Successfully created $entityName: \${item.id}');
      return item;
  }''');
          break;

        case 'update':
          methods.add('''
  @override
  Future<$entityName> update(UpdateParams<${config.useMorphy ? '${entityName}Patch' : 'Partial<$entityName>'}> params) async {
    logger.info('Updating $entityName: \${params.id} with data: \${params.data}');
    await Future.delayed(_delay);
    final existing = ${entityName}MockData.${entityCamel}s.firstWhere(
      (item) => item.id == params.id,
      orElse: () => throw NotFoundFailure('$entityName not found: \${params.id}'),
    );
    // In a real implementation, you'd apply the update
    logger.info('Successfully updated $entityName: \${params.id}');
    return existing;
  }''');
          break;

        case 'delete':
          methods.add('''
  @override
  Future<void> delete(String id) async {
    logger.info('Deleting $entityName: \$id');
    await Future.delayed(_delay);
    final exists = ${entityName}MockData.${entityCamel}s.any((item) => item.id == id);
    if (!exists) {
      throw NotFoundFailure('$entityName not found: \$id');
    }
    // In a real implementation, you'd remove from storage
    logger.info('Successfully deleted $entityName: \$id');
  }''');
          break;

        case 'watch':
          methods.add('''
  @override
  Stream<$entityName> watch(String id) {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      final item = ${entityName}MockData.${entityCamel}s.firstWhere(
        (item) => item.id == id,
        orElse: () => throw NotFoundFailure('$entityName not found: \$id'),
      );
      return item;
    }).take(10); // Limit for demo
  }''');
          break;

        case 'watchList':
          methods.add('''
  @override
  Stream<List<$entityName>> watchList(ListQueryParams params) {
    return Stream.periodic(const Duration(seconds: 2), (count) {
      var items = ${entityName}MockData.${entityCamel}s;
      if (params.limit != null && params.limit! > 0) {
        items = items.take(params.limit!).toList();
      }
      return items;
    }).take(5); // Limit for demo
  }''');
          break;
      }
    }

    return methods.join('\n');
  }
}
