// Generated by zfa

import '../models/generator_config.dart';
import '../models/generated_file.dart';
import '../utils/string_utils.dart';
import '../utils/entity_analyzer.dart';
import '../utils/file_utils.dart';

class MockGenerator {
  static Future<List<GeneratedFile>> generate(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final files = <GeneratedFile>[];

    // Check if main entity is polymorphic (abstract with subtypes)
    final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
      config.name,
      outputDir,
    );
    final isPolymorphic = subtypes.isNotEmpty;

    // Skip generating mock data for abstract polymorphic types
    if (!isPolymorphic) {
      // Generate mock data file for main entity
      final mockDataFile = await _generateMockDataFile(
        config,
        outputDir,
        dryRun: dryRun,
        force: force,
        verbose: verbose,
      );
      files.add(mockDataFile);
    } else if (verbose) {
      print(
        '  → Skipping mock data for abstract polymorphic type: ${config.name}',
      );
    }

    // Generate mock data files for nested entities (including subtypes)
    final nestedEntityFiles = await _generateNestedEntityMockFiles(
      config,
      outputDir,
      dryRun: dryRun,
      force: force,
      verbose: verbose,
    );
    files.addAll(nestedEntityFiles);

    // Generate mock data source if not mock-data-only
    if (!config.generateMockDataOnly) {
      final mockDataSourceFile = await _generateMockDataSource(
        config,
        outputDir,
        dryRun: dryRun,
        force: force,
        verbose: verbose,
      );
      files.add(mockDataSourceFile);
    }

    return files;
  }

  static Future<List<GeneratedFile>> _generateNestedEntityMockFiles(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final files = <GeneratedFile>[];
    final entityName = config.name;
    final entityFields = EntityAnalyzer.analyzeEntity(entityName, outputDir);
    final processedEntities = <String>{
      entityName,
    }; // Avoid generating for main entity

    // Check if main entity is polymorphic and generate subtypes first
    final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
      entityName,
      outputDir,
    );
    if (subtypes.isNotEmpty && verbose) {
      print(
        '  → Detected polymorphic entity $entityName with subtypes: ${subtypes.join(', ')}',
      );
    }

    // Generate mock data for each subtype
    for (final subtype in subtypes) {
      if (!processedEntities.contains(subtype)) {
        processedEntities.add(subtype);

        if (verbose) {
          print('  → Generating mock for polymorphic subtype: $subtype');
        }

        final subtypeConfig = GeneratorConfig(
          name: subtype,
          generateMockDataOnly: true,
        );
        final subtypeMockFile = await _generateMockDataFile(
          subtypeConfig,
          outputDir,
          dryRun: dryRun,
          force: force,
          verbose: verbose,
        );
        files.add(subtypeMockFile);

        // Recursively process nested entities within this subtype
        final subtypeFields = EntityAnalyzer.analyzeEntity(subtype, outputDir);
        await _collectAndGenerateNestedEntities(
          subtypeFields,
          outputDir,
          files,
          processedEntities,
          dryRun: dryRun,
          force: force,
          verbose: verbose,
        );
      }
    }

    // Process nested entities in the main entity's fields
    await _collectAndGenerateNestedEntities(
      entityFields,
      outputDir,
      files,
      processedEntities,
      dryRun: dryRun,
      force: force,
      verbose: verbose,
    );

    return files;
  }

  static Future<void> _collectAndGenerateNestedEntities(
    Map<String, String> fields,
    String outputDir,
    List<GeneratedFile> files,
    Set<String> processedEntities, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    for (final entry in fields.entries) {
      final fieldType = entry.value;
      final baseTypes = _extractEntityTypesFromField(fieldType);

      for (final baseType in baseTypes) {
        // Check if it's a custom type (PascalCase) and not already processed
        if (baseType.isNotEmpty &&
            baseType[0] == baseType[0].toUpperCase() &&
            ![
              'String',
              'int',
              'double',
              'bool',
              'DateTime',
              'Object',
              'dynamic',
            ].contains(baseType) &&
            !processedEntities.contains(baseType)) {
          // Check if it's a polymorphic type with subtypes
          final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
            baseType,
            outputDir,
          );
          if (subtypes.isNotEmpty) {
            // Skip the abstract type, but generate its subtypes
            processedEntities.add(baseType);

            if (verbose) {
              print('  → Skipping polymorphic abstract type: $baseType');
              print('  → Generating subtypes: ${subtypes.join(', ')}');
            }

            // Generate mock data for each subtype
            for (final subtype in subtypes) {
              if (!processedEntities.contains(subtype)) {
                processedEntities.add(subtype);

                if (verbose) {
                  print('  → Generating mock for subtype: $subtype');
                }

                final subtypeConfig = GeneratorConfig(
                  name: subtype,
                  generateMockDataOnly: true,
                );
                final subtypeMockFile = await _generateMockDataFile(
                  subtypeConfig,
                  outputDir,
                  dryRun: dryRun,
                  force: force,
                  verbose: verbose,
                );
                files.add(subtypeMockFile);

                // Recursively process nested entities within this subtype
                final subtypeFields = EntityAnalyzer.analyzeEntity(
                  subtype,
                  outputDir,
                );
                await _collectAndGenerateNestedEntities(
                  subtypeFields,
                  outputDir,
                  files,
                  processedEntities,
                  dryRun: dryRun,
                  force: force,
                  verbose: verbose,
                );
              }
            }
            continue;
          }

          // Check if it's an entity (has fields)
          final entityFields = EntityAnalyzer.analyzeEntity(
            baseType,
            outputDir,
          );
          if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
            processedEntities.add(baseType);

            if (verbose) {
              print('  → Generating mock for nested entity: $baseType');
            }

            // Generate mock data file for this nested entity
            final nestedConfig = GeneratorConfig(
              name: baseType,
              generateMockDataOnly: true,
            );
            final nestedMockFile = await _generateMockDataFile(
              nestedConfig,
              outputDir,
              dryRun: dryRun,
              force: force,
              verbose: verbose,
            );
            files.add(nestedMockFile);

            // Recursively process nested entities within this entity
            await _collectAndGenerateNestedEntities(
              entityFields,
              outputDir,
              files,
              processedEntities,
              dryRun: dryRun,
              force: force,
              verbose: verbose,
            );
          } else if (verbose) {
            print(
              '  → Skipping $baseType (not an entity, enum, or complex type)',
            );
          }
        }
      }
    }
  }

  static List<String> _extractEntityTypesFromField(String fieldType) {
    final types = <String>[];
    var baseType = fieldType.replaceAll('?', '');

    // Handle List<Type>
    if (baseType.startsWith('List<') && baseType.endsWith('>')) {
      baseType = baseType.substring(5, baseType.length - 1);
    }
    // Handle Map<K,V> - extract value type
    else if (baseType.startsWith('Map<') && baseType.endsWith('>')) {
      final innerTypes = baseType.substring(4, baseType.length - 1);
      final typeParts = innerTypes.split(',').map((s) => s.trim()).toList();
      if (typeParts.length == 2) {
        // Process the value type (second part)
        baseType = typeParts[1];
      } else {
        return types; // Skip malformed map types
      }
    }

    // Handle zorphy entity indicator ($EntityName)
    if (baseType.startsWith('\$')) {
      baseType = baseType.substring(1);
    }

    // Clean up any remaining generic markers
    baseType = baseType
        .replaceAll('<', '')
        .replaceAll('>', '')
        .split(',')[0] // Take first type if there are multiple
        .trim();

    if (baseType.isNotEmpty) {
      types.add(baseType);
    }

    return types;
  }

  static bool _isDefaultFields(Map<String, String> fields) {
    // Check if these are the default fallback fields
    final defaultKeys = {
      'id',
      'name',
      'description',
      'price',
      'category',
      'isActive',
      'createdAt',
      'updatedAt',
    };
    return fields.keys.toSet().containsAll(defaultKeys);
  }

  static List<String> _collectNestedEntityImports(
    Map<String, String> fields,
    String outputDir,
  ) {
    final imports = <String>[];
    bool hasEnums = false;

    for (final entry in fields.entries) {
      final fieldType = entry.value;

      // Extract base type from complex types
      var baseType = fieldType.replaceAll('?', '');

      // Handle List<Type>
      if (baseType.startsWith('List<') && baseType.endsWith('>')) {
        baseType = baseType.substring(5, baseType.length - 1);
      }

      // Handle Map<K,V> - extract value type for entity detection
      if (baseType.startsWith('Map<') && baseType.endsWith('>')) {
        final innerTypes = baseType.substring(4, baseType.length - 1);
        final typeParts = innerTypes.split(',').map((s) => s.trim()).toList();
        if (typeParts.length == 2) {
          // Process the value type (second part)
          baseType = typeParts[1];
        } else {
          continue; // Skip malformed map types
        }
      }

      // Handle zorphy entity indicator ($EntityName)
      if (baseType.startsWith('\$')) {
        baseType = baseType.substring(1);
      }

      // Skip primitive types
      if ([
        'String',
        'int',
        'double',
        'bool',
        'DateTime',
        'Object',
      ].contains(baseType)) {
        continue;
      }

      // Check if it's a custom type (PascalCase)
      if (baseType.isNotEmpty && baseType[0] == baseType[0].toUpperCase()) {
        // Check if it's a polymorphic type with subtypes
        final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
          baseType,
          outputDir,
        );
        if (subtypes.isNotEmpty) {
          // Import mock data for each subtype instead of abstract type
          for (final subtype in subtypes) {
            final subtypeSnake = StringUtils.camelToSnake(subtype);
            imports.add('../mock/${subtypeSnake}_mock_data.dart');
          }
          continue; // Skip the abstract type itself
        }

        // Check if it's an entity (has fields)
        final entityFields = EntityAnalyzer.analyzeEntity(baseType, outputDir);
        if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
          final entitySnake = StringUtils.camelToSnake(baseType);
          // Import the mock data file
          imports.add('../mock/${entitySnake}_mock_data.dart');
        } else {
          // It's likely an enum - only add import if this entity directly uses it
          hasEnums = true;
        }
      }
    }

    // Add single enum import only if this entity directly has enum fields
    if (hasEnums) {
      imports.insert(0, '../../domain/entities/enums/index.dart');
    }

    return imports.toSet().toList(); // Remove duplicates
  }

  static Future<GeneratedFile> _generateMockDataFile(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final entityName = config.name;
    final entitySnake = StringUtils.camelToSnake(entityName);
    final entityCamel = StringUtils.pascalToCamel(entityName);

    // Try to analyze entity for realistic mock data
    final entityFields = EntityAnalyzer.analyzeEntity(entityName, outputDir);

    final mockData = _generateMockDataInstances(
      entityName,
      entityFields,
      outputDir,
    );

    // Collect imports for nested entities
    final imports = _collectNestedEntityImports(entityFields, outputDir);
    final importStatements = imports
        .map((import) => "import '$import';")
        .join('\n');

    final content =
        '''
// Generated by zfa
// Mock data for $entityName

import '../../domain/entities/$entitySnake/$entitySnake.dart';
${importStatements.isNotEmpty ? '$importStatements\n' : ''}
class ${entityName}MockData {
  static final List<$entityName> ${entityCamel}s = [
$mockData
  ];

  static $entityName get sample$entityName => ${entityCamel}s.first;
  static List<$entityName> get sampleList => ${entityCamel}s;
  static List<$entityName> get emptyList => [];

  static List<$entityName> get large${entityName}List => List.generate(
    100,
    (index) => _create$entityName(index + 1000),
  );

  static $entityName _create$entityName(int seed) {
    return $entityName(
${_generateConstructorCall(entityFields, useSeeds: true, outputDir: outputDir)}
    );
  }
}
''';

    final filePath = '$outputDir/data/mock/${entitySnake}_mock_data.dart';
    return FileUtils.writeFile(
      filePath,
      content,
      'mock_data',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  static Future<GeneratedFile> _generateMockDataSource(
    GeneratorConfig config,
    String outputDir, {
    bool dryRun = false,
    bool force = false,
    bool verbose = false,
  }) async {
    final entityName = config.name;
    final entitySnake = StringUtils.camelToSnake(entityName);
    final entityCamel = StringUtils.pascalToCamel(entityName);

    final methods = _generateMockDataSourceMethods(
      config,
      entityName,
      entityCamel,
    );

    final content =
        '''
// Generated by zfa
// Mock data source for $entityName

import 'dart:async';
import 'package:zuraffa/zuraffa.dart';
import '../../../domain/entities/$entitySnake/$entitySnake.dart';
import '../../mock/${entitySnake}_mock_data.dart';
import '${entitySnake}_data_source.dart';

class ${entityName}MockDataSource with Loggable, FailureHandler implements ${entityName}DataSource {
  final Duration _delay;

  ${entityName}MockDataSource({Duration? delay})
    : _delay = delay ?? const Duration(milliseconds: 100);

${config.generateInit ? '''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing ${entityName}MockDataSource');
    // Mock initialization - nothing to do
    await Future.delayed(const Duration(seconds: 1));
    logger.info('${entityName}MockDataSource initialized');
  }

  @override
  Stream<bool> get isInitialized => Stream.value(true);

''' : ''}$methods
}
''';

    final filePath =
        '$outputDir/data/data_sources/$entitySnake/${entitySnake}_mock_data_source.dart';
    return FileUtils.writeFile(
      filePath,
      content,
      'mock_data_source',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  static String _generateMockDataInstances(
    String entityName,
    Map<String, String> fields,
    String outputDir,
  ) {
    final instances = <String>[];

    // If no fields found, generate empty constructor calls
    if (fields.isEmpty) {
      for (int i = 1; i <= 3; i++) {
        instances.add('''    $entityName(),''');
      }
      return instances.join('\n');
    }

    // Generate 3 instances with field values
    for (int i = 1; i <= 3; i++) {
      instances.add('''    $entityName(
${_generateConstructorCall(fields, seed: i, outputDir: outputDir)}
    ),''');
    }

    return instances.join('\n');
  }

  static String _generateConstructorCall(
    Map<String, String> fields, {
    int seed = 1,
    bool useSeeds = false,
    required String outputDir,
  }) {
    final params = <String>[];

    for (final entry in fields.entries) {
      final fieldName = entry.key;
      final fieldType = entry.value;
      final mockValue = _generateMockValue(
        fieldName,
        fieldType,
        seed,
        useSeeds,
        outputDir,
      );
      params.add('      $fieldName: $mockValue,');
    }

    return params.join('\n');
  }

  static String _generateMockValue(
    String fieldName,
    String fieldType,
    int seed,
    bool useSeeds,
    String outputDir,
  ) {
    // Handle nullable types
    final isNullable = fieldType.endsWith('?');
    final baseType = fieldType.replaceAll('?', '');

    if (useSeeds) {
      return _generateSeededValue(fieldName, baseType, isNullable, outputDir);
    }

    // Generate values ONLY based on field type
    switch (baseType) {
      case 'String':
        return "'$fieldName $seed'";

      case 'int':
        return '${seed * 10}';

      case 'double':
        return '${seed * 10.5}';

      case 'bool':
        return seed % 2 == 1 ? 'true' : 'false';

      case 'DateTime':
        return 'DateTime.now().subtract(const Duration(days: ${seed * 30}))';

      case 'Object':
        return '{"key$seed": "value$seed"}';

      default:
        // Handle List types
        if (baseType.startsWith('List<') && baseType.endsWith('>')) {
          final listType = baseType.substring(5, baseType.length - 1);
          return _generateListValue(listType, seed, outputDir);
        }

        // Handle Map types
        if (baseType.startsWith('Map<') && baseType.endsWith('>')) {
          return _generateMapValue(baseType, seed, outputDir);
        }

        // Handle custom classes/enums
        if (isNullable && seed % 3 == 0) return 'null';

        // Check if it's likely an enum or class
        if (baseType.isNotEmpty && baseType[0] == baseType[0].toUpperCase()) {
          // Handle zorphy entity indicator ($EntityName)
          final cleanType = baseType.startsWith('\$')
              ? baseType.substring(1)
              : baseType;

          // Check if it's a polymorphic type with subtypes
          final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
            cleanType,
            outputDir,
          );
          if (subtypes.isNotEmpty) {
            // Use one of the subtypes based on seed
            final subtypeIndex = seed % subtypes.length;
            final subtype = subtypes[subtypeIndex];
            return '${subtype}MockData.sample$subtype';
          }

          // Try to detect if it's an entity by checking if it has fields
          final entityFields = EntityAnalyzer.analyzeEntity(
            cleanType,
            outputDir,
          );
          if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
            // It's an entity - reference its mock data
            return '${cleanType}MockData.sample$cleanType';
          }
          // Otherwise treat as enum - use modulo 2 to stay safe
          return '$baseType.values[${seed % 2}]';
        }

        return "'$fieldName $seed'";
    }
  }

  static String _generateListValue(
    String listType,
    int seed,
    String outputDir,
  ) {
    // Handle zorphy entity indicator ($EntityName)
    final cleanListType = listType.startsWith('\$')
        ? listType.substring(1)
        : listType;

    // Generate a list with 2-3 items
    final itemCount = 2 + (seed % 2);
    final items = <String>[];

    // Check if listType is an entity (exclude primitive types)
    if (cleanListType.isNotEmpty &&
        cleanListType[0] == cleanListType[0].toUpperCase() &&
        ![
          'String',
          'int',
          'double',
          'bool',
          'DateTime',
          'Object',
          'dynamic',
        ].contains(cleanListType)) {
      // Check if it's a polymorphic type with subtypes
      final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
        cleanListType,
        outputDir,
      );

      if (subtypes.isNotEmpty) {
        // Mix different subtypes in the list
        for (int i = 0; i < itemCount; i++) {
          final subtypeIndex = (seed + i) % subtypes.length;
          final subtype = subtypes[subtypeIndex];
          final itemIndex = i % 3;
          items.add(
            '${subtype}MockData.${StringUtils.pascalToCamel(subtype)}s[$itemIndex]',
          );
        }
        return '[${items.join(', ')}]';
      }

      final entityFields = EntityAnalyzer.analyzeEntity(
        cleanListType,
        outputDir,
      );
      if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
        // Reference different items from the mock data
        for (int i = 1; i <= itemCount; i++) {
          final itemIndex = (seed + i - 1) % 3;
          items.add(
            '${cleanListType}MockData.${StringUtils.pascalToCamel(cleanListType)}s[$itemIndex]',
          );
        }
        return '[${items.join(', ')}]';
      } else {
        // Force generate mock data for this nested entity if it doesn't exist
        // This ensures ListingOffer gets its mock data generated
        for (int i = 0; i < itemCount; i++) {
          items.add('${cleanListType}MockData.sample$cleanListType');
        }
        return '[${items.join(', ')}]';
      }
    }

    // For primitive types or enums
    for (int i = 1; i <= itemCount; i++) {
      final itemValue = _generateMockValue(
        'item',
        cleanListType,
        seed + i,
        false,
        outputDir,
      );
      items.add(itemValue);
    }

    return '[${items.join(', ')}]';
  }

  static String _generateMapValue(String mapType, int seed, String outputDir) {
    // Extract key and value types from Map<K, V>
    final innerTypes = mapType.substring(
      4,
      mapType.length - 1,
    ); // Remove "Map<" and ">"
    final typeParts = innerTypes.split(',').map((s) => s.trim()).toList();

    if (typeParts.length != 2) {
      return '{}'; // Fallback for malformed map types
    }

    final keyType = typeParts[0];
    final valueType = typeParts[1];

    // Generate 2-3 key-value pairs
    final itemCount = 2 + (seed % 2);
    final entries = <String>[];

    for (int i = 1; i <= itemCount; i++) {
      final keyValue = _generateSimpleValue(keyType, 'key$i', seed + i);
      final valueValue = _generateMockValue(
        'value$i',
        valueType,
        seed + i,
        false,
        outputDir,
      );
      entries.add('$keyValue: $valueValue');
    }

    return '{${entries.join(', ')}}';
  }

  static String _generateSimpleValue(String type, String name, int seed) {
    switch (type) {
      case 'String':
        return "'$name'";
      case 'int':
        return '${seed * 10}';
      case 'double':
        return '${seed * 10.5}';
      case 'bool':
        return seed % 2 == 1 ? 'true' : 'false';
      default:
        return "'$name'"; // Fallback to string
    }
  }

  static String _generateSeededValue(
    String fieldName,
    String baseType,
    bool isNullable,
    String outputDir,
  ) {
    switch (baseType) {
      case 'String':
        return "'$fieldName \$seed'";
      case 'int':
        return 'seed * 10';
      case 'double':
        return 'seed * 10.5';
      case 'bool':
        return 'seed % 2 == 1';
      case 'DateTime':
        return 'DateTime.now().subtract(Duration(days: seed * 30))';
      case 'Object':
        return '{"key\$seed": "value\$seed"}';
      default:
        // Handle List types
        if (baseType.startsWith('List<') && baseType.endsWith('>')) {
          final listType = baseType.substring(5, baseType.length - 1);
          return _generateSeededListValue(listType, outputDir);
        }

        // Handle Map types
        if (baseType.startsWith('Map<') && baseType.endsWith('>')) {
          return _generateSeededMapValue(baseType, outputDir);
        }

        // Handle custom classes/enums
        if (baseType.isNotEmpty && baseType[0] == baseType[0].toUpperCase()) {
          // Handle zorphy entity indicator ($EntityName)
          final cleanType = baseType.startsWith('\$')
              ? baseType.substring(1)
              : baseType;

          // Check if it's a polymorphic type with subtypes
          final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
            cleanType,
            outputDir,
          );
          if (subtypes.isNotEmpty) {
            // Use one of the subtypes based on seed
            final subtype = subtypes[0]; // Use first subtype for seeded value
            return '${subtype}MockData.sample$subtype';
          }

          // Try to detect if it's an entity by checking if it has fields
          final entityFields = EntityAnalyzer.analyzeEntity(
            cleanType,
            outputDir,
          );
          if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
            // It's an entity - reference its mock data
            return '${cleanType}MockData.sample$cleanType';
          }
          // Otherwise treat as enum - use modulo 2 to stay safe
          return '$cleanType.values[seed % 2]';
        }
        return "'$fieldName \$seed'";
    }
  }

  static String _generateSeededListValue(String listType, String outputDir) {
    // Handle zorphy entity indicator ($EntityName)
    final cleanListType = listType.startsWith('\$')
        ? listType.substring(1)
        : listType;

    // Check if listType is an entity (exclude primitive types)
    if (cleanListType.isNotEmpty &&
        cleanListType[0] == cleanListType[0].toUpperCase() &&
        ![
          'String',
          'int',
          'double',
          'bool',
          'DateTime',
          'Object',
          'dynamic',
        ].contains(cleanListType)) {
      // Check if it's a polymorphic type with subtypes
      final subtypes = EntityAnalyzer.getPolymorphicSubtypes(
        cleanListType,
        outputDir,
      );

      if (subtypes.isNotEmpty) {
        // Mix different subtypes in the list (3 items, one of each subtype if possible)
        final items = <String>[];
        for (int i = 0; i < 3 && i < subtypes.length; i++) {
          final subtype = subtypes[i];
          items.add(
            '${subtype}MockData.${StringUtils.pascalToCamel(subtype)}s[seed % 3]',
          );
        }
        // If we have fewer than 3 subtypes, cycle through them
        while (items.length < 3) {
          final subtype = subtypes[items.length % subtypes.length];
          items.add(
            '${subtype}MockData.${StringUtils.pascalToCamel(subtype)}s[(seed + ${items.length}) % 3]',
          );
        }
        return '[${items.join(', ')}]';
      }

      final entityFields = EntityAnalyzer.analyzeEntity(
        cleanListType,
        outputDir,
      );
      if (entityFields.isNotEmpty && !_isDefaultFields(entityFields)) {
        // Reference mock data items with seed-based indices
        return '[${cleanListType}MockData.${StringUtils.pascalToCamel(cleanListType)}s[seed % 3], ${cleanListType}MockData.${StringUtils.pascalToCamel(cleanListType)}s[(seed + 1) % 3]]';
      } else {
        // Force generate mock data for this nested entity if it doesn't exist
        return '[${cleanListType}MockData.sample$cleanListType, ${cleanListType}MockData.sample$cleanListType]';
      }
    }

    // For primitive types, generate simple values
    switch (cleanListType) {
      case 'String':
        return "['item \$seed', 'item \$seed']";
      case 'int':
        return '[\$seed, \$seed + 1]';
      case 'double':
        return '[\$seed * 1.5, \$seed * 2.5]';
      case 'bool':
        return '[true, false]';
      default:
        return '[$cleanListType(), $cleanListType()]';
    }
  }

  static String _generateSeededMapValue(String mapType, String outputDir) {
    // Extract key and value types from Map<K, V>
    final innerTypes = mapType.substring(
      4,
      mapType.length - 1,
    ); // Remove "Map<" and ">"
    final typeParts = innerTypes.split(',').map((s) => s.trim()).toList();

    if (typeParts.length != 2) {
      return '{}'; // Fallback for malformed map types
    }

    final keyType = typeParts[0];
    final valueType = typeParts[1];

    // Generate seeded key-value pairs
    final keyValue1 = _generateSeededSimpleValue(keyType, 'key');
    final valueValue1 = _generateSeededValue(
      'value',
      valueType,
      false,
      outputDir,
    );
    final keyValue2 = keyType == 'String'
        ? "'key2 \$seed'"
        : _generateSeededSimpleValue(keyType, 'key2');
    final valueValue2 = valueType == 'String'
        ? "'value2 \$seed'"
        : _generateSeededValue('value2', valueType, false, outputDir);

    return '{$keyValue1: $valueValue1, $keyValue2: $valueValue2}';
  }

  static String _generateSeededSimpleValue(String type, String name) {
    switch (type) {
      case 'String':
        return "'$name \$seed'";
      case 'int':
        return 'seed * 10';
      case 'double':
        return 'seed * 10.5';
      case 'bool':
        return 'seed % 2 == 1';
      default:
        return "'$name \$seed'"; // Fallback to string
    }
  }

  static String _generateMockDataSourceMethods(
    GeneratorConfig config,
    String entityName,
    String entityCamel,
  ) {
    final methods = <String>[];

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          if (config.idField == 'null') {
            methods.add('''
  @override
  Future<$entityName> get() async {
    logger.info('Getting $entityName');
    await Future.delayed(_delay);
    final item = ${entityName}MockData.sample$entityName;
    logger.info('Successfully retrieved $entityName');
    return item;
  }''');
          } else {
            methods.add('''
  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    logger.info('Getting $entityName with params: \$params');
    await Future.delayed(_delay);
    final item = ${entityName}MockData.${entityCamel}s.query(params);
    logger.info('Successfully retrieved $entityName');
    return item;
  }''');
          }
          break;

        case 'getList':
          methods.add('''
  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    logger.info('Getting $entityName list with params: \$params');
    await Future.delayed(_delay);
    var items = ${entityName}MockData.${entityCamel}s;

    // Apply limit if specified
    if (params.limit != null && params.limit! > 0) {
      items = items.take(params.limit!).toList();
    }

    logger.info('Successfully retrieved \${items.length} ${entityName}s');
    return items;
  }''');
          break;

        case 'create':
          methods.add('''
  @override
  Future<$entityName> create($entityName item) async {
      logger.info('Creating $entityName: \${item.id}');
      await Future.delayed(_delay);
      // In a real implementation, you'd add to storage
      logger.info('Successfully created $entityName: \${item.id}');
      return item;
  }''');
          break;

        case 'update':
          final dataType = config.useZorphy
              ? '${entityName}Patch'
              : 'Map<String, dynamic>';
          methods.add('''
  @override
  Future<$entityName> update(UpdateParams<$entityName, $dataType> params) async {
    logger.info('Updating $entityName with id: \${params.id}');
    await Future.delayed(_delay);
    final existing = ${entityName}MockData.${entityCamel}s.firstWhere(
      (item) => item.${config.idField} == params.id,
      orElse: () => throw notFoundFailure('$entityName not found'),
    );
    // In a real implementation, you'd apply the update
    logger.info('Successfully updated $entityName');
    return existing;
  }''');
          break;

        case 'delete':
          methods.add('''
  @override
  Future<void> delete(DeleteParams<$entityName> params) async {
    logger.info('Deleting $entityName with id: \${params.id}');
    await Future.delayed(_delay);
    final exists = ${entityName}MockData.${entityCamel}s.any((item) => item.${config.idField} == params.id);
    if (!exists) {
      throw notFoundFailure('$entityName not found');
    }
    // In a real implementation, you'd remove from storage
    logger.info('Successfully deleted $entityName');
  }''');
          break;

        case 'watch':
          if (config.idField == 'null') {
            methods.add('''
  @override
  Stream<$entityName> watch() {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      return ${entityName}MockData.sample$entityName;
    }).take(10); // Limit for demo
  }''');
          } else {
            methods.add('''
  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    return Stream.periodic(const Duration(seconds: 1), (count) {
      final item = ${entityName}MockData.${entityCamel}s.query(params);
      return item;
    }).take(10); // Limit for demo
  }''');
          }
          break;

        case 'watchList':
          methods.add('''
  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    return Stream.periodic(const Duration(seconds: 2), (count) {
      var items = ${entityName}MockData.${entityCamel}s;
      if (params.limit != null && params.limit! > 0) {
        items = items.take(params.limit!).toList();
      }
      return items;
    }).take(5); // Limit for demo
  }''');
          break;
      }
    }

    return methods.join('\n\n');
  }
}
