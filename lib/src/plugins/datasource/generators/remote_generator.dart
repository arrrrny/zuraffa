import 'package:path/path.dart' as path;

import '../../../models/generated_file.dart';
import '../../../models/generator_config.dart';
import '../../../utils/file_utils.dart';
import '../../../utils/string_utils.dart';

class RemoteDataSourceGenerator {
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;

  RemoteDataSourceGenerator({
    required this.outputDir,
    required this.dryRun,
    required this.force,
    required this.verbose,
  });

  Future<GeneratedFile> generate(GeneratorConfig config) async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final dataSourceName = '${entityName}RemoteDataSource';
    final fileName = '${entitySnake}_remote_data_source.dart';

    final dataSourceDirPath = path.join(
      outputDir,
      'data',
      'data_sources',
      entitySnake,
    );
    final filePath = path.join(dataSourceDirPath, fileName);

    final methods = <String>[];
    if (config.generateInit) {
      methods.add(
        '''
  @override
  Future<void> initialize(InitializationParams params) async {
    logger.info('Initializing $dataSourceName');
    // TODO: Initialize remote connection, auth, etc.
    logger.info('$dataSourceName initialized');
  }''',
      );
      methods.add(
        '''
  @override
  Stream<bool> get isInitialized => Stream.value(true);''',
      );
    }

    final gqlImports = <String>[];

    for (final method in config.methods) {
      final gqlConstant = config.generateGql
          ? _graphqlConstantName(config, method)
          : null;
      final gqlFile = config.generateGql
          ? _graphqlFileName(config, method)
          : null;
      if (gqlFile != null) {
        gqlImports.add('graphql/$gqlFile');
      }
      switch (method) {
        case 'get':
          methods.add(
            '''
  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    // TODO: Implement remote API call
    ${_remoteBody('Implement remote get', gqlConstant)}
  }''',
          );
          break;
        case 'getList':
          methods.add(
            '''
  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    // TODO: Implement remote API call
    ${_remoteBody('Implement remote getList', gqlConstant)}
  }''',
          );
          break;
        case 'create':
          methods.add(
            '''
  @override
  Future<$entityName> create($entityName $entityCamel) async {
    // TODO: Implement remote API call
    ${_remoteBody('Implement remote create', gqlConstant)}
  }''',
          );
          break;
        case 'update':
          final dataType = config.useZorphy
              ? '${config.name}Patch'
              : 'Partial<${config.name}>';
          methods.add(
            '''
  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    // TODO: Implement remote API call
    ${_remoteBody('Implement remote update', gqlConstant)}
  }''',
          );
          break;
        case 'delete':
          methods.add(
            '''
  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    // TODO: Implement remote API call
    ${_remoteBody('Implement remote delete', gqlConstant)}
  }''',
          );
          break;
        case 'watch':
          methods.add(
            '''
  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    ${_remoteBody('Implement remote watch', gqlConstant)}
  }''',
          );
          break;
        case 'watchList':
          methods.add(
            '''
  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    // TODO: Implement remote stream (WebSocket, SSE, etc.)
    ${_remoteBody('Implement remote watchList', gqlConstant)}
  }''',
          );
          break;
      }
    }

    final importLines = [
      "import 'package:zuraffa/zuraffa.dart';",
      "import '../../../domain/entities/$entitySnake/$entitySnake.dart';",
      "import '${entitySnake}_data_source.dart';",
      ...gqlImports.map((gqlImport) => "import '$gqlImport';"),
    ];

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data --cache

${importLines.join('\n')}

/// Remote data source for $entityName.
///
/// Fetches data from external API/service.
class $dataSourceName with Loggable, FailureHandler implements ${entityName}DataSource {
  // TODO: Add HTTP client or API service dependency
  // final ApiClient _apiClient;
  // $dataSourceName(this._apiClient);

${methods.join('\n\n')}
}
''';

    return FileUtils.writeFile(
      filePath,
      content,
      'remote_datasource',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  String _remoteBody(String fallback, String? gqlConstant) {
    if (gqlConstant != null) {
      return 'throw UnimplementedError($gqlConstant);';
    }
    return "throw UnimplementedError('$fallback');";
  }

  String _graphqlConstantName(GeneratorConfig config, String method) {
    final operationType = _getOperationType(config, method);
    final operationName = _getOperationName(method, config.name);
    return '${StringUtils.pascalToCamel(operationName)}'
        '${StringUtils.convertToPascalCase(operationType)}';
  }

  String _graphqlFileName(GeneratorConfig config, String method) {
    final operationType = _getOperationType(config, method);
    final operationName = _getOperationName(method, config.name);
    return '${StringUtils.camelToSnake(operationName)}_$operationType.dart';
  }

  String _getOperationType(GeneratorConfig config, String method) {
    if (config.gqlType != null) {
      return config.gqlType!;
    }
    switch (method) {
      case 'get':
      case 'getList':
        return 'query';
      case 'create':
      case 'update':
      case 'delete':
        return 'mutation';
      case 'watch':
      case 'watchList':
        return 'subscription';
      default:
        return 'query';
    }
  }

  String _getOperationName(String method, String entityName) {
    switch (method) {
      case 'get':
        return 'Get$entityName';
      case 'getList':
        return 'Get${entityName}List';
      case 'create':
        return 'Create$entityName';
      case 'update':
        return 'Update$entityName';
      case 'delete':
        return 'Delete$entityName';
      case 'watch':
        return 'Watch$entityName';
      case 'watchList':
        return 'Watch${entityName}List';
      default:
        return method + entityName;
    }
  }
}
