import 'dart:io';

import '../../../core/ast/append_executor.dart';
import '../../../core/ast/strategies/append_strategy.dart';
import '../../../models/generated_file.dart';
import '../../../models/generator_config.dart';
import '../../../utils/file_utils.dart';

class RepositoryImplementationGenerator {
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final AppendExecutor appendExecutor;

  RepositoryImplementationGenerator({
    required this.outputDir,
    required this.dryRun,
    required this.force,
    required this.verbose,
    AppendExecutor? appendExecutor,
  }) : appendExecutor = appendExecutor ?? AppendExecutor();

  Future<GeneratedFile> generate(GeneratorConfig config) async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final repoName = '${entityName}Repository';
    final dataRepoName = 'Data${entityName}Repository';

    final dataSourceName = '${entityName}DataSource';
    final localDataSourceName = '${entityName}LocalDataSource';
    final fileName = 'data_${entitySnake}_repository.dart';
    final filePath = '$outputDir/data/repositories/$fileName';

    final constructorParams = _buildConstructorParams(
      config,
      dataRepoName,
      dataSourceName,
      localDataSourceName,
    );
    final methods = _buildMethods(config, entityName, entityCamel);
    final imports = _buildImports(
      config,
      entitySnake,
      dataSourceName,
      localDataSourceName,
    );

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data${config.enableCache ? ' --cache=${config.cachePolicy}' : ''}${config.generateLocal ? ' --local' : ''}

${imports.join('\n')}

class $dataRepoName with Loggable, FailureHandler implements $repoName {
$constructorParams

${methods.join('\n\n')}
}
''';

    if (config.appendToExisting && File(filePath).existsSync()) {
      final existing = await File(filePath).readAsString();
      final mergedImports = _mergeImports(existing, imports);
      final appended = _appendMethods(
        source: mergedImports,
        className: dataRepoName,
        methods: methods,
      );
      return FileUtils.writeFile(
        filePath,
        appended,
        'data_repository',
        force: true,
        dryRun: dryRun,
        verbose: verbose,
      );
    }

    return FileUtils.writeFile(
      filePath,
      content,
      'data_repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  String _buildConstructorParams(
    GeneratorConfig config,
    String dataRepoName,
    String dataSourceName,
    String localDataSourceName,
  ) {
    if (config.generateLocal) {
      return '''  final $localDataSourceName _dataSource;

  $dataRepoName(this._dataSource);''';
    }
    if (config.enableCache) {
      return '''  final $dataSourceName _remoteDataSource;
  final $localDataSourceName _localDataSource;
  final CachePolicy _cachePolicy;

  $dataRepoName(
    this._remoteDataSource,
    this._localDataSource,
    this._cachePolicy,
  );''';
    }
    return '''  final $dataSourceName _dataSource;

  $dataRepoName(this._dataSource);''';
  }

  List<String> _buildMethods(
    GeneratorConfig config,
    String entityName,
    String entityCamel,
  ) {
    final methods = <String>[];
    if (config.generateInit) {
      if (config.enableCache) {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _remoteDataSource.isInitialized;''');
        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _remoteDataSource.initialize(params);
  }''');
      } else {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _dataSource.isInitialized;''');
        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _dataSource.initialize(params);
  }''');
      }
    }
    for (final method in config.methods) {
      if (config.enableCache) {
        methods.add(_generateCachedMethod(config, method, entityName, entityCamel));
      } else {
        methods.add(_generateSimpleMethod(config, method, entityName, entityCamel));
      }
    }
    return methods;
  }

  List<String> _buildImports(
    GeneratorConfig config,
    String entitySnake,
    String dataSourceName,
    String localDataSourceName,
  ) {
    final hasWatchMethods = config.methods.any(
      (m) => m == 'watch' || m == 'watchList',
    );
    final asyncImport = config.enableCache && hasWatchMethods ? "import 'dart:async';" : null;

    final imports = <String>[];
    if (asyncImport != null) {
      imports.add(asyncImport);
    }
    imports.add("import 'package:zuraffa/zuraffa.dart';");
    imports.add("import '../../domain/entities/$entitySnake/$entitySnake.dart';");
    imports.add("import '../../domain/repositories/${entitySnake}_repository.dart';");

    if (config.generateLocal) {
      imports.add(
        "import '../data_sources/$entitySnake/${entitySnake}_local_data_source.dart';",
      );
    } else if (config.enableCache) {
      imports.add(
        "import '../data_sources/$entitySnake/${entitySnake}_data_source.dart';",
      );
      imports.add(
        "import '../data_sources/$entitySnake/${entitySnake}_local_data_source.dart';",
      );
    } else {
      imports.add(
        "import '../data_sources/$entitySnake/${entitySnake}_data_source.dart';",
      );
    }

    return imports;
  }

  String _generateSimpleMethod(
    GeneratorConfig config,
    String method,
    String entityName,
    String entityCamel,
  ) {
    switch (method) {
      case 'get':
        return '''  @override
  Future<$entityName> get(QueryParams<$entityName> params) {
    return _dataSource.get(params);
  }''';
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) {
    return _dataSource.getList(params);
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) {
    return _dataSource.create($entityCamel);
  }''';
      case 'update':
        final dataType = config.useZorphy
            ? '${config.name}Patch'
            : 'Partial<${config.name}>';
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) {
    return _dataSource.update(params);
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<${config.idType}> params) {
    return _dataSource.delete(params);
  }''';
      case 'watch':
        return '''  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    return _dataSource.watch(params);
  }''';
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    return _dataSource.watchList(params);
  }''';
      default:
        return '';
    }
  }

  String _generateCachedMethod(
    GeneratorConfig config,
    String method,
    String entityName,
    String entityCamel,
  ) {
    final baseCacheKey = '${config.nameSnake}_cache';
    switch (method) {
      case 'get':
        return '''  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    if (await _cachePolicy.isValid('$baseCacheKey')) {
      try {
        return await _localDataSource.get(params);
      } catch (_) {}
    }
    final data = await _remoteDataSource.get(params);
    await _localDataSource.save(data);
    await _cachePolicy.markFresh('$baseCacheKey');
    return data;
  }''';
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    final listCacheKey = '${baseCacheKey}_\${params.hashCode}';
    if (await _cachePolicy.isValid(listCacheKey)) {
      try {
        return await _localDataSource.getList(params);
      } catch (_) {}
    }
    final data = await _remoteDataSource.getList(params);
    await _localDataSource.saveAll(data);
    await _cachePolicy.markFresh(listCacheKey);
    return data;
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) async {
    final data = await _remoteDataSource.create($entityCamel);
    await _localDataSource.save(data);
    await _cachePolicy.invalidate('$baseCacheKey');
    return data;
  }''';
      case 'update':
        final dataType = config.useZorphy
            ? '${config.name}Patch'
            : 'Partial<${config.name}>';
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    final data = await _remoteDataSource.update(params);
    await _localDataSource.save(data);
    await _cachePolicy.invalidate('$baseCacheKey');
    return data;
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    await _remoteDataSource.delete(params);
    await _localDataSource.delete(params);
    await _cachePolicy.invalidate('$baseCacheKey');
  }''';
      case 'watch':
        return '''  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    return _remoteDataSource.watch(params);
  }''';
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    return _remoteDataSource.watchList(params);
  }''';
      default:
        return '';
    }
  }

  String _appendMethods({
    required String source,
    required String className,
    required List<String> methods,
  }) {
    var updated = source;
    for (final methodSource in methods) {
      final stripped = methodSource.trimLeft();
      final result = appendExecutor.execute(
        AppendRequest.method(
          source: updated,
          className: className,
          memberSource: stripped,
        ),
      );
      updated = result.source;
    }
    return updated;
  }

  String _mergeImports(String source, List<String> imports) {
    var updated = source;
    for (final importLine in imports) {
      if (!updated.contains(importLine)) {
        updated = '$importLine\n$updated';
      }
    }
    return updated;
  }
}
