import 'dart:io';

import '../../../core/ast/append_executor.dart';
import '../../../core/ast/strategies/append_strategy.dart';
import '../../../models/generated_file.dart';
import '../../../models/generator_config.dart';
import '../../../utils/file_utils.dart';

class RepositoryImplementationGenerator {
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final AppendExecutor appendExecutor;

  RepositoryImplementationGenerator({
    required this.outputDir,
    required this.dryRun,
    required this.force,
    required this.verbose,
    AppendExecutor? appendExecutor,
  }) : appendExecutor = appendExecutor ?? AppendExecutor();

  Future<GeneratedFile> generate(GeneratorConfig config) async {
    final entityName = config.name;
    final entitySnake = config.nameSnake;
    final entityCamel = config.nameCamel;
    final repoName = '${entityName}Repository';
    final dataRepoName = 'Data${entityName}Repository';

    final fileName = 'data_${entitySnake}_repository.dart';
    final filePath = '$outputDir/data/repositories/$fileName';

    final methods = <String>[];

    final dataSourceName = '${entityName}DataSource';
    final localDataSourceName = '${entityName}LocalDataSource';

    final constructorParams = config.generateLocal
        ? '''  final $localDataSourceName _dataSource;

  $dataRepoName(this._dataSource);'''
        : config.enableCache
            ? '''  final $dataSourceName _remoteDataSource;
  final $localDataSourceName _localDataSource;
  final CachePolicy _cachePolicy;

  $dataRepoName(
    this._remoteDataSource,
    this._localDataSource,
    this._cachePolicy,
  );'''
            : '''  final $dataSourceName _dataSource;

  $dataRepoName(this._dataSource);''';

    if (config.generateInit) {
      if (config.enableCache) {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _remoteDataSource.isInitialized;''');

        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _remoteDataSource.initialize(params);
  }''');
      } else {
        methods.add('''
  @override
  Stream<bool> get isInitialized => _dataSource.isInitialized;''');

        methods.add('''
  @override
  Future<void> initialize(InitializationParams params) {
    return _dataSource.initialize(params);
  }''');
      }
    }

    for (final method in config.methods) {
      if (config.enableCache) {
        methods.add(
          _generateCachedMethod(config, method, entityName, entityCamel),
        );
      } else {
        methods.add(
          _generateSimpleMethod(config, method, entityName, entityCamel),
        );
      }
    }

    final dataSourceImport = config.generateLocal
        ? '''import '../data_sources/$entitySnake/${entitySnake}_local_data_source.dart';'''
        : config.enableCache
            ? '''import '../data_sources/$entitySnake/${entitySnake}_data_source.dart';
import '../data_sources/$entitySnake/${entitySnake}_local_data_source.dart';'''
            : '''import '../data_sources/$entitySnake/${entitySnake}_data_source.dart';''';

    final hasWatchMethods = config.methods.any(
      (m) => m == 'watch' || m == 'watchList',
    );
    final asyncImport = config.enableCache && hasWatchMethods
        ? "import 'dart:async';\n\n"
        : '';

    final content =
        '''
// Generated by zfa
// zfa generate $entityName --methods=${config.methods.join(',')} --data${config.enableCache ? ' --cache=${config.cachePolicy}' : ''}${config.generateLocal ? ' --local' : ''}

${asyncImport}import 'package:zuraffa/zuraffa.dart';
import '../../domain/entities/$entitySnake/$entitySnake.dart';
import '../../domain/repositories/${entitySnake}_repository.dart';
$dataSourceImport

class $dataRepoName with Loggable, FailureHandler implements $repoName {
$constructorParams

${methods.join('\n\n')}
}
''';

    if (config.appendToExisting && File(filePath).existsSync()) {
      final existing = await File(filePath).readAsString();
      final importPaths = _buildImportPaths(config, entitySnake);
      final importLines = _buildImportLines(importPaths);
      final mergedImports = _mergeImports(existing, importLines);
      final appended = _appendMethods(
        source: mergedImports,
        className: dataRepoName,
        methods: methods,
      );
      return FileUtils.writeFile(
        filePath,
        appended,
        'data_repository',
        force: true,
        dryRun: dryRun,
        verbose: verbose,
      );
    }

    return FileUtils.writeFile(
      filePath,
      content,
      'data_repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  String _generateSimpleMethod(
    GeneratorConfig config,
    String method,
    String entityName,
    String entityCamel,
  ) {
    switch (method) {
      case 'get':
        return '''  @override
  Future<$entityName> get(QueryParams<$entityName> params) {
    return _dataSource.get(params);
  }''';
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) {
    return _dataSource.getList(params);
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) {
    return _dataSource.create($entityCamel);
  }''';
      case 'update':
        final dataType = config.useZorphy
            ? '${config.name}Patch'
            : 'Partial<${config.name}>';
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) {
    return _dataSource.update(params);
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<${config.idType}> params) {
    return _dataSource.delete(params);
  }''';
      case 'watch':
        return '''  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    return _dataSource.watch(params);
  }''';
      case 'watchList':
        return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    return _dataSource.watchList(params);
  }''';
      default:
        return '';
    }
  }

  String _generateCachedMethod(
    GeneratorConfig config,
    String method,
    String entityName,
    String entityCamel,
  ) {
    final baseCacheKey = '${config.nameSnake}_cache';

    switch (method) {
      case 'get':
        return '''  @override
  Future<$entityName> get(QueryParams<$entityName> params) async {
    // Check cache validity
    if (await _cachePolicy.isValid('$baseCacheKey')) {
      try {
        return await _localDataSource.get(params);
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.get(params);

    // Update cache
    await _localDataSource.save(data);
    await _cachePolicy.markFresh('$baseCacheKey');

    return data;
  }''';
      case 'getList':
        return '''  @override
  Future<List<$entityName>> getList(ListQueryParams<$entityName> params) async {
    // Include params in cache key for granular caching
    final listCacheKey = '${baseCacheKey}_\${params.hashCode}';

    // Check cache validity
    if (await _cachePolicy.isValid(listCacheKey)) {
      try {
        return await _localDataSource.getList(params);
      } catch (e) {
        logger.severe('Cache miss, fetching from remote');
      }
    }

    // Fetch from remote
    final data = await _remoteDataSource.getList(params);

    // Update cache
    await _localDataSource.saveAll(data);
    await _cachePolicy.markFresh(listCacheKey);

    return data;
  }''';
      case 'create':
        return '''  @override
  Future<$entityName> create($entityName $entityCamel) async {
    // Create on remote
    final created = await _remoteDataSource.create($entityCamel);

    // Update local cache
    await _localDataSource.save(created);

    // Invalidate list cache since a new item was added
    await _cachePolicy.invalidate('$baseCacheKey');

    return created;
  }''';
      case 'update':
        final dataType = config.useZorphy
            ? '${config.name}Patch'
            : 'Partial<${config.name}>';
        return '''  @override
  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params) async {
    // Update on remote
    final updated = await _remoteDataSource.update(params);

    // Update local cache
    await _localDataSource.update(params);

    // Invalidate cache since data was modified
    await _cachePolicy.invalidate('$baseCacheKey');

    return updated;
  }''';
      case 'delete':
        return '''  @override
  Future<void> delete(DeleteParams<${config.idType}> params) async {
    // Delete from remote
    await _remoteDataSource.delete(params);

    // Delete from local cache
    await _localDataSource.delete(params);

    // Invalidate all cache since data was removed
    await _cachePolicy.invalidate('$baseCacheKey');
  }''';
      case 'watch':
        return _buildWatchBody(config, entityName);
      case 'watchList':
        return _buildWatchListBody(config, entityName);
      default:
        return '';
    }
  }

  List<String> _buildImportPaths(GeneratorConfig config, String entitySnake) {
    final hasWatchMethods = config.methods.any(
      (m) => m == 'watch' || m == 'watchList',
    );
    final asyncImport = config.enableCache && hasWatchMethods
        ? 'dart:async'
        : null;

    final imports = <String>[];
    if (asyncImport != null) {
      imports.add(asyncImport);
    }
    imports.add('package:zuraffa/zuraffa.dart');
    imports.add('../../domain/entities/$entitySnake/$entitySnake.dart');
    imports.add('../../domain/repositories/${entitySnake}_repository.dart');

    if (config.generateLocal) {
      imports.add(
        '../data_sources/$entitySnake/${entitySnake}_local_data_source.dart',
      );
    } else if (config.enableCache) {
      imports.add(
        '../data_sources/$entitySnake/${entitySnake}_data_source.dart',
      );
      imports.add(
        '../data_sources/$entitySnake/${entitySnake}_local_data_source.dart',
      );
    } else {
      imports.add(
        '../data_sources/$entitySnake/${entitySnake}_data_source.dart',
      );
    }
    return imports;
  }

  List<String> _buildImportLines(List<String> importPaths) {
    return importPaths.map((path) => "import '$path';").toList();
  }

  String _appendMethods({
    required String source,
    required String className,
    required List<String> methods,
  }) {
    var updated = source;
    for (final methodSource in methods) {
      final result = appendExecutor.execute(
        AppendRequest.method(
          source: updated,
          className: className,
          memberSource: methodSource,
        ),
      );
      updated = result.source;
    }
    return updated;
  }

  String _mergeImports(String source, List<String> imports) {
    var updated = source;
    for (final importLine in imports) {
      if (!updated.contains(importLine)) {
        updated = '$importLine\n$updated';
      }
    }
    return updated;
  }

  String _buildWatchBody(GeneratorConfig config, String entityName) {
    final baseCacheKey = '${config.nameSnake}_cache';
    return '''  @override
  Stream<$entityName> watch(QueryParams<$entityName> params) {
    // Local drives the stream, remote syncs in background
    late final StreamController<$entityName> controller;
    StreamSubscription<$entityName>? localSub;
    StreamSubscription<$entityName>? remoteSub;

    controller = StreamController<$entityName>(
      onListen: () {
        localSub = _localDataSource.watch(params).listen(
          controller.add,
          onError: controller.addError,
        );
        remoteSub = _remoteDataSource.watch(params).listen(
          (data) async {
            try {
              await _localDataSource.save(data);
              await _cachePolicy.markFresh('$baseCacheKey');
            } catch (e) {
              logger.warning('Failed to persist remote update: \$e');
            }
          },
          onError: (e) => logger.warning('Remote watch error: \$e'),
        );
      },
      onCancel: () async {
        await remoteSub?.cancel();
        await localSub?.cancel();
      },
    );

    return controller.stream;
  }''';
  }

  String _buildWatchListBody(GeneratorConfig config, String entityName) {
    final baseCacheKey = '${config.nameSnake}_cache';
    return '''  @override
  Stream<List<$entityName>> watchList(ListQueryParams<$entityName> params) {
    // Local drives the stream, remote syncs in background
    late final StreamController<List<$entityName>> controller;
    StreamSubscription<List<$entityName>>? localSub;
    StreamSubscription<List<$entityName>>? remoteSub;

    controller = StreamController<List<$entityName>>(
      onListen: () {
        localSub = _localDataSource.watchList(params).listen(
          controller.add,
          onError: controller.addError,
        );
        remoteSub = _remoteDataSource.watchList(params).listen(
          (data) async {
            try {
              await _localDataSource.saveAll(data);
              await _cachePolicy.markFresh('$baseCacheKey');
            } catch (e) {
              logger.warning('Failed to persist remote update: \$e');
            }
          },
          onError: (e) => logger.warning('Remote watch error: \$e'),
        );
      },
      onCancel: () async {
        await remoteSub?.cancel();
        await localSub?.cancel();
      },
    );

    return controller.stream;
  }''';
  }
}
