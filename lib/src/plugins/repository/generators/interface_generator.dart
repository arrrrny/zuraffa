import 'dart:io';

import 'package:code_builder/code_builder.dart';

import '../../../core/ast/append_executor.dart';
import '../../../core/ast/strategies/append_strategy.dart';
import '../../../core/builder/shared/spec_library.dart';
import '../../../models/generated_file.dart';
import '../../../models/generator_config.dart';
import '../../../utils/file_utils.dart';

class RepositoryInterfaceGenerator {
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final AppendExecutor appendExecutor;
  final SpecLibrary specLibrary;

  RepositoryInterfaceGenerator({
    required this.outputDir,
    required this.dryRun,
    required this.force,
    required this.verbose,
    AppendExecutor? appendExecutor,
    SpecLibrary? specLibrary,
  }) : appendExecutor = appendExecutor ?? AppendExecutor(),
       specLibrary = specLibrary ?? const SpecLibrary();

  Future<GeneratedFile> generate(GeneratorConfig config) async {
    final repoName = '${config.name}Repository';
    final fileName = '${config.nameSnake}_repository.dart';
    final filePath = '$outputDir/domain/repositories/$fileName';

    final methods = _buildMethods(config);
    final importPaths = _buildImportPaths(config);
    final content = specLibrary.emitLibrary(
      specLibrary.library(
        specs: [
          Class(
            (b) => b
              ..name = repoName
              ..abstract = true
              ..methods.addAll(methods),
          ),
        ],
        directives: importPaths.map(Directive.import),
      ),
    );
    final header =
        '// Generated by zfa\n// zfa generate ${config.name} --methods=${config.methods.join(',')} --repository';
    final normalizedContent = content.replaceAll('\n\nimport', '\nimport');
    final output = '$header\n\n$normalizedContent';

    if (config.appendToExisting && File(filePath).existsSync()) {
      final existing = await File(filePath).readAsString();
      final importLines = _buildImportLines(importPaths);
      final mergedImports = _mergeImports(existing, importLines);
      final appended = _appendMethods(
        source: mergedImports,
        className: repoName,
        methods: methods,
      );
      return FileUtils.writeFile(
        filePath,
        appended,
        'repository',
        force: true,
        dryRun: dryRun,
        verbose: verbose,
      );
    }

    return FileUtils.writeFile(
      filePath,
      output,
      'repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  List<String> _buildImportPaths(GeneratorConfig config) {
    final needsZuraffaImport =
        config.methods.any(
          (method) =>
              method == 'getList' ||
              method == 'update' ||
              method == 'delete' ||
              method == 'watchList',
        ) ||
        config.generateInit;

    final imports = <String>[];
    if (needsZuraffaImport) {
      imports.add('package:zuraffa/zuraffa.dart');
    }
    imports.add('../entities/${config.nameSnake}/${config.nameSnake}.dart');
    return imports;
  }

  List<Method> _buildMethods(GeneratorConfig config) {
    final methods = <Method>[];
    if (config.generateInit) {
      methods.add(
        Method(
          (b) => b
            ..name = 'isInitialized'
            ..type = MethodType.getter
            ..returns = refer('Stream<bool>'),
        ),
      );
      methods.add(
        Method(
          (b) => b
            ..name = 'initialize'
            ..returns = refer('Future<void>')
            ..requiredParameters.add(
              Parameter(
                (p) => p
                  ..name = 'params'
                  ..type = refer('InitializationParams'),
              ),
            ),
        ),
      );
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          methods.add(
            _buildMethod(
              name: 'get',
              returnType: 'Future<${config.name}>',
              paramsType: 'QueryParams<${config.name}>',
              paramsName: 'params',
            ),
          );
          break;
        case 'getList':
          methods.add(
            _buildMethod(
              name: 'getList',
              returnType: 'Future<List<${config.name}>>',
              paramsType: 'ListQueryParams<${config.name}>',
              paramsName: 'params',
            ),
          );
          break;
        case 'create':
          methods.add(
            _buildMethod(
              name: 'create',
              returnType: 'Future<${config.name}>',
              paramsType: config.name,
              paramsName: config.nameCamel,
            ),
          );
          break;
        case 'update':
          final dataType = config.useZorphy
              ? '${config.name}Patch'
              : 'Partial<${config.name}>';
          methods.add(
            _buildMethod(
              name: 'update',
              returnType: 'Future<${config.name}>',
              paramsType: 'UpdateParams<${config.idType}, $dataType>',
              paramsName: 'params',
            ),
          );
          break;
        case 'delete':
          methods.add(
            _buildMethod(
              name: 'delete',
              returnType: 'Future<void>',
              paramsType: 'DeleteParams<${config.idType}>',
              paramsName: 'params',
            ),
          );
          break;
        case 'watch':
          methods.add(
            _buildMethod(
              name: 'watch',
              returnType: 'Stream<${config.name}>',
              paramsType: 'QueryParams<${config.name}>',
              paramsName: 'params',
            ),
          );
          break;
        case 'watchList':
          methods.add(
            _buildMethod(
              name: 'watchList',
              returnType: 'Stream<List<${config.name}>>',
              paramsType: 'ListQueryParams<${config.name}>',
              paramsName: 'params',
            ),
          );
          break;
      }
    }
    return methods;
  }

  Method _buildMethod({
    required String name,
    required String returnType,
    required String paramsType,
    required String paramsName,
  }) {
    return Method(
      (b) => b
        ..name = name
        ..returns = refer(returnType)
        ..requiredParameters.add(
          Parameter(
            (p) => p
              ..name = paramsName
              ..type = refer(paramsType),
          ),
        ),
    );
  }

  String _appendMethods({
    required String source,
    required String className,
    required List<Method> methods,
  }) {
    var updated = source;
    for (final method in methods) {
      final methodSource = _emitMethod(method);
      final result = appendExecutor.execute(
        AppendRequest.method(
          source: updated,
          className: className,
          memberSource: methodSource,
        ),
      );
      updated = result.source;
    }
    return updated;
  }

  String _mergeImports(String source, List<String> imports) {
    var updated = source;
    for (final importLine in imports) {
      if (!updated.contains(importLine)) {
        updated = '$importLine\n$updated';
      }
    }
    return updated;
  }

  List<String> _buildImportLines(List<String> importPaths) {
    return importPaths.map((path) => "import '$path';").toList();
  }

  String _emitMethod(Method method) {
    final emitter = DartEmitter(
      orderDirectives: true,
      useNullSafetySyntax: true,
    );
    return method.accept(emitter).toString();
  }
}
