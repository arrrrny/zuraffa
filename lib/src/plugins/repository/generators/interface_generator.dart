import 'dart:io';

import '../../../core/ast/append_executor.dart';
import '../../../core/ast/strategies/append_strategy.dart';
import '../../../models/generated_file.dart';
import '../../../models/generator_config.dart';
import '../../../utils/file_utils.dart';

class RepositoryInterfaceGenerator {
  final String outputDir;
  final bool dryRun;
  final bool force;
  final bool verbose;
  final AppendExecutor appendExecutor;

  RepositoryInterfaceGenerator({
    required this.outputDir,
    required this.dryRun,
    required this.force,
    required this.verbose,
    AppendExecutor? appendExecutor,
  }) : appendExecutor = appendExecutor ?? AppendExecutor();

  Future<GeneratedFile> generate(GeneratorConfig config) async {
    final repoName = '${config.name}Repository';
    final fileName = '${config.nameSnake}_repository.dart';
    final filePath = '$outputDir/domain/repositories/$fileName';

    final methods = _buildMethodSources(config);
    final imports = _buildImports(config);

    final content =
        '''
// Generated by zfa
// zfa generate ${config.name} --methods=${config.methods.join(',')} --repository

${imports.join('\n')}

abstract class $repoName {
${methods.join('\n')}
}
''';

    if (config.appendToExisting && File(filePath).existsSync()) {
      final existing = await File(filePath).readAsString();
      final mergedImports = _mergeImports(existing, imports);
      final appended = _appendMethods(
        source: mergedImports,
        className: repoName,
        methods: methods,
      );
      return FileUtils.writeFile(
        filePath,
        appended,
        'repository',
        force: true,
        dryRun: dryRun,
        verbose: verbose,
      );
    }

    return FileUtils.writeFile(
      filePath,
      content,
      'repository',
      force: force,
      dryRun: dryRun,
      verbose: verbose,
    );
  }

  List<String> _buildImports(GeneratorConfig config) {
    final needsZuraffaImport =
        config.methods.any(
          (method) =>
              method == 'getList' ||
              method == 'update' ||
              method == 'delete' ||
              method == 'watchList',
        ) ||
        config.generateInit;

    final imports = <String>[];
    if (needsZuraffaImport) {
      imports.add("import 'package:zuraffa/zuraffa.dart';");
    }
    imports.add(
      "import '../entities/${config.nameSnake}/${config.nameSnake}.dart';",
    );
    return imports;
  }

  List<String> _buildMethodSources(GeneratorConfig config) {
    final methods = <String>[];

    if (config.generateInit) {
      methods.add('  Stream<bool> get isInitialized;');
      methods.add('  Future<void> initialize(InitializationParams params);');
    }

    for (final method in config.methods) {
      switch (method) {
        case 'get':
          methods.add(
            '  Future<${config.name}> get(QueryParams<${config.name}> params);',
          );
          break;
        case 'getList':
          methods.add(
            '  Future<List<${config.name}>> getList(ListQueryParams<${config.name}> params);',
          );
          break;
        case 'create':
          methods.add(
            '  Future<${config.name}> create(${config.name} ${config.nameCamel});',
          );
          break;
        case 'update':
          final dataType = config.useZorphy
              ? '${config.name}Patch'
              : 'Partial<${config.name}>';
          methods.add(
            '  Future<${config.name}> update(UpdateParams<${config.idType}, $dataType> params);',
          );
          break;
        case 'delete':
          methods.add(
            '  Future<void> delete(DeleteParams<${config.idType}> params);',
          );
          break;
        case 'watch':
          methods.add(
            '  Stream<${config.name}> watch(QueryParams<${config.name}> params);',
          );
          break;
        case 'watchList':
          methods.add(
            '  Stream<List<${config.name}>> watchList(ListQueryParams<${config.name}> params);',
          );
          break;
      }
    }

    return methods;
  }

  String _appendMethods({
    required String source,
    required String className,
    required List<String> methods,
  }) {
    var updated = source;
    for (final methodSource in methods) {
      final stripped = methodSource.trimLeft();
      final result = appendExecutor.execute(
        AppendRequest.method(
          source: updated,
          className: className,
          memberSource: stripped,
        ),
      );
      updated = result.source;
    }
    return updated;
  }

  String _mergeImports(String source, List<String> imports) {
    var updated = source;
    for (final importLine in imports) {
      if (!updated.contains(importLine)) {
        updated = '$importLine\n$updated';
      }
    }
    return updated;
  }
}
