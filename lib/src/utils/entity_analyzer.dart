// Generated by zfa

import 'dart:io';
import 'string_utils.dart';

class EntityAnalyzer {
  /// Analyzes an entity file to extract field information for mock data generation
  static Map<String, String> analyzeEntity(
    String entityName,
    String outputDir,
  ) {
    final entitySnake = StringUtils.camelToSnake(entityName);

    // All entities are at entities/{entity_snake}/{entity_snake}.dart
    final entityPath =
        '$outputDir/domain/entities/$entitySnake/$entitySnake.dart';

    try {
      final file = File(entityPath);
      if (!file.existsSync()) {
        return _getDefaultFields();
      }

      final content = file.readAsStringSync();

      // Check if this is a Zorphy entity (contains @Zorphy annotation)
      if (content.contains('@Zorphy')) {
        // Try to parse from the generated .zorphy.dart file first
        final zorphyPath =
            '$outputDir/domain/entities/$entitySnake/$entitySnake.zorphy.dart';
        final zorphyFile = File(zorphyPath);
        if (zorphyFile.existsSync()) {
          final zorphyContent = zorphyFile.readAsStringSync();
          final zorphyFields = _parseEntityFields(zorphyContent, entityName);
          if (zorphyFields.isNotEmpty && !_hasOnlyDefaultFields(zorphyFields)) {
            return zorphyFields;
          }
          // If parsing the class failed, try parsing all final fields in the file
          final allFieldsRegex = RegExp(
            r'final\s+([\w\?\$<>,\s\[\]]+)\s+(\w+)\s*;',
            multiLine: true,
          );
          final allFieldMatches = allFieldsRegex.allMatches(zorphyContent);
          final allFields = <String, String>{};
          for (final match in allFieldMatches) {
            final type = match.group(1)?.trim();
            final name = match.group(2);
            if (type != null && name != null && !_isIgnoredField(name)) {
              allFields[name] = type;
            }
          }
          if (allFields.isNotEmpty) {
            return allFields;
          }
        }
      }

      // Try both regular name and zorphy name ($EntityName)
      var fields = _parseEntityFields(content, entityName);
      if (fields.isEmpty || _hasOnlyDefaultFields(fields)) {
        fields = _parseEntityFields(content, '\$$entityName');
      }
      if (fields.isNotEmpty && !_hasOnlyDefaultFields(fields)) {
        return fields;
      }
    } catch (e) {
      // Continue to fallback
    }

    // Fallback to default fields if parsing fails
    return _getDefaultFields();
  }

  static Map<String, String> _parseEntityFields(
    String content,
    String targetEntityName,
  ) {
    final fields = <String, String>{};

    // Find the specific class/abstract class definition by name
    final classRegex = RegExp(
      r'(?:abstract\s+)?class\s+' +
          RegExp.escape(targetEntityName) +
          r'(?:\s+extends\s+\w+)?(?:\s+implements\s+[\w\s,]+)?\s*\{',
      multiLine: true,
    );
    final classMatch = classRegex.firstMatch(content);

    if (classMatch != null) {
      final startIndex = classMatch.end;

      // Find the matching closing brace using balanced brace counting
      int braceCount = 1;
      int endIndex = startIndex;

      for (int i = startIndex; i < content.length && braceCount > 0; i++) {
        if (content[i] == '{') {
          braceCount++;
        } else if (content[i] == '}') {
          braceCount--;
        }
        endIndex = i;
      }

      final classBody = content.substring(startIndex, endIndex);

      // Parse getter-style fields within this class body
      final getterRegex = RegExp(
        r'([\w\?\$<>,\s]+)\s+get\s+(\w+)\s*;',
        multiLine: true,
      );
      final getterMatches = getterRegex.allMatches(classBody);

      for (final match in getterMatches) {
        final type = match.group(1)?.trim();
        final name = match.group(2);

        if (type != null && name != null && !_isIgnoredField(name)) {
          fields[name] = type;
        }
      }

      // Parse field declarations within this class body
      final fieldRegex = RegExp(
        r'final\s+([\w\?\$<>,\s\[\]]+)\s+(\w+)\s*;',
        multiLine: true,
      );
      final fieldMatches = fieldRegex.allMatches(classBody);

      for (final match in fieldMatches) {
        final type = match.group(1)?.trim();
        final name = match.group(2);

        if (type != null && name != null && !_isIgnoredField(name)) {
          fields[name] = type;
        }
      }
    }

    // If no class-specific fields found, fall back to the old method
    if (fields.isEmpty) {
      // Parse getter-style fields: Type get fieldName;
      final getterRegex = RegExp(
        r'(\w+(?:\?)?(?:<[^>]+>)?)\s+get\s+(\w+)\s*;',
        multiLine: true,
      );
      final getterMatches = getterRegex.allMatches(content);

      for (final match in getterMatches) {
        final type = match.group(1);
        final name = match.group(2);

        if (type != null && name != null && !_isIgnoredField(name)) {
          fields[name] = type;
        }
      }
    }

    // If still no fields found, return defaults
    return fields.isEmpty ? _getDefaultFields() : fields;
  }

  static bool _isIgnoredField(String fieldName) {
    // Ignore common method names and reserved words
    final ignored = {
      'toString',
      'hashCode',
      'runtimeType',
      'props',
      'copyWith',
      'toJson',
      'fromJson',
      'when',
      'map',
      'maybeWhen',
      'maybeMap',
    };
    return ignored.contains(fieldName);
  }

  static Map<String, String> _getDefaultFields() {
    // NEVER use fallback fields - only use actual entity fields
    return {};
  }

  static bool _hasOnlyDefaultFields(Map<String, String> fields) {
    // Check if these are the default fallback fields
    final defaultKeys = {
      'id',
      'name',
      'description',
      'price',
      'category',
      'isActive',
      'createdAt',
      'updatedAt',
    };
    return fields.keys.toSet().containsAll(defaultKeys);
  }

  /// Detects if an entity is polymorphic (has explicitSubTypes in @Zorphy)
  /// Returns list of subtype names (without $ prefix)
  static List<String> getPolymorphicSubtypes(
    String entityName,
    String outputDir,
  ) {
    final entitySnake = StringUtils.camelToSnake(entityName);
    final entityPath =
        '$outputDir/domain/entities/$entitySnake/$entitySnake.dart';

    try {
      final file = File(entityPath);
      if (!file.existsSync()) return [];

      final content = file.readAsStringSync();

      // Look for @Zorphy annotation with explicitSubTypes
      final zorphyRegex = RegExp(
        r'@Zorphy\s*\([^)]*explicitSubTypes\s*:\s*\[([^\]]+)\]',
        multiLine: true,
        dotAll: true,
      );
      final match = zorphyRegex.firstMatch(content);

      if (match != null) {
        final subtypesStr = match.group(1);
        if (subtypesStr != null) {
          // Extract subtype names (e.g., $BarcodeUrlTemplate -> BarcodeUrlTemplate)
          final subtypeRegex = RegExp(r'\$(\w+)');
          final subtypes = subtypeRegex
              .allMatches(subtypesStr)
              .map((m) => m.group(1)!)
              .toList();
          return subtypes;
        }
      }
    } catch (e) {
      // Ignore errors
    }

    return [];
  }
}
