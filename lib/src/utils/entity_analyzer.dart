// Generated by zfa

import 'dart:io';
import 'string_utils.dart';

class EntityAnalyzer {
  /// Analyzes an entity file to extract field information for mock data generation
  static Map<String, String> analyzeEntity(
      String entityName, String outputDir) {
    final entitySnake = StringUtils.camelToSnake(entityName);

    // All entities are at entities/{entity_snake}/{entity_snake}.dart
    final entityPath =
        '$outputDir/domain/entities/$entitySnake/$entitySnake.dart';

    try {
      final file = File(entityPath);
      if (!file.existsSync()) {
        return _getDefaultFields();
      }

      final content = file.readAsStringSync();
      // Try both regular name and morphy name ($EntityName)
      var fields = _parseEntityFields(content, entityName);
      if (fields.isEmpty || _hasOnlyDefaultFields(fields)) {
        fields = _parseEntityFields(content, '\$$entityName');
      }
      if (fields.isNotEmpty && !_hasOnlyDefaultFields(fields)) {
        return fields;
      }
    } catch (e) {
      // Continue to fallback
    }

    // Fallback to default fields if parsing fails
    return _getDefaultFields();
  }

  static Map<String, String> _parseEntityFields(
      String content, String targetEntityName) {
    final fields = <String, String>{};

    // Find the specific class/abstract class definition by name
    final classRegex = RegExp(
        r'(?:abstract\s+)?class\s+' +
            RegExp.escape(targetEntityName) +
            r'\s*\{',
        multiLine: true);
    final classMatch = classRegex.firstMatch(content);

    if (classMatch != null) {
      final startIndex = classMatch.end;

      // Find the matching closing brace using balanced brace counting
      int braceCount = 1;
      int endIndex = startIndex;

      for (int i = startIndex; i < content.length && braceCount > 0; i++) {
        if (content[i] == '{') {
          braceCount++;
        } else if (content[i] == '}') {
          braceCount--;
        }
        endIndex = i;
      }

      final classBody = content.substring(startIndex, endIndex);

      // Parse getter-style fields within this class body
      final getterRegex =
          RegExp(r'([\w\?<>,\s]+)\s+get\s+(\w+)\s*;', multiLine: true);
      final getterMatches = getterRegex.allMatches(classBody);

      for (final match in getterMatches) {
        final type = match.group(1)?.trim();
        final name = match.group(2);

        if (type != null && name != null && !_isIgnoredField(name)) {
          fields[name] = type;
        }
      }

      // Parse field declarations within this class body
      final fieldRegex =
          RegExp(r'final\s+([\w\?<>,\s]+)\s+(\w+)\s*;', multiLine: true);
      final fieldMatches = fieldRegex.allMatches(classBody);

      for (final match in fieldMatches) {
        final type = match.group(1)?.trim();
        final name = match.group(2);

        if (type != null && name != null && !_isIgnoredField(name)) {
          fields[name] = type;
        }
      }
    }

    // If no class-specific fields found, fall back to the old method
    if (fields.isEmpty) {
      // Parse getter-style fields: Type get fieldName;
      final getterRegex = RegExp(r'(\w+(?:\?)?(?:<[^>]+>)?)\s+get\s+(\w+)\s*;',
          multiLine: true);
      final getterMatches = getterRegex.allMatches(content);

      for (final match in getterMatches) {
        final type = match.group(1);
        final name = match.group(2);

        if (type != null && name != null && !_isIgnoredField(name)) {
          fields[name] = type;
        }
      }
    }

    // If still no fields found, return defaults
    return fields.isEmpty ? _getDefaultFields() : fields;
  }

  static bool _isIgnoredField(String fieldName) {
    // Ignore common method names and reserved words
    final ignored = {
      'toString',
      'hashCode',
      'runtimeType',
      'props',
      'copyWith',
      'toJson',
      'fromJson',
      'when',
      'map',
      'maybeWhen',
      'maybeMap'
    };
    return ignored.contains(fieldName);
  }

  static Map<String, String> _getDefaultFields() {
    return {
      'id': 'String',
      'name': 'String',
      'description': 'String',
      'price': 'double',
      'category': 'String',
      'isActive': 'bool',
      'createdAt': 'DateTime',
      'updatedAt': 'DateTime?',
    };
  }

  static bool _hasOnlyDefaultFields(Map<String, String> fields) {
    // Check if these are the default fallback fields
    final defaultKeys = {
      'id',
      'name',
      'description',
      'price',
      'category',
      'isActive',
      'createdAt',
      'updatedAt'
    };
    return fields.keys.toSet().containsAll(defaultKeys);
  }
}
